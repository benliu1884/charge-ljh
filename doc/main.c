#include "port.h"
#include <rtthread.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
//#include <pthread.h>
#include "ccm_if.h"
#include "charge.h"
#include "record.h"
#include "gcard.h"
#include "backend_if.h"
#include "env.h"
#include "ui_com.h"
#include "alarm.h"
#include "whiltelist.h"
//#include "qrcode.h"

#if 1

// #define SONGLI_DEFAULT
// #define SN_IN_FLASH_ADDRESS 0x8003FA0
extern int at_socket_initialized();
#if defined(RT_USING_ADC)
extern int MX_ADCx_Init(void);
#endif
extern void meter_process(void);
static char _use_console;

// static void check_device_sn(void)
// {
//     char sn[17];
//     snprintf(sn, 17, "%d", *(unsigned int *)SN_IN_FLASH_ADDRESS);
//     if(env_get("sn")==NULL) {
//         if(*(unsigned int *)SN_IN_FLASH_ADDRESS == 0xffffffff) {
//             _use_console = 1;
//         }
//         else
//             env_set("sn",sn);
//     }
// }
#ifdef ENABLE_WATCH_DOG
#ifndef IWDG_DEVICE_NAME
#define IWDG_DEVICE_NAME    "iwg"    /* 看门狗设备名称 */
#endif
static rt_device_t wdg_dev;         /* 看门狗设备句柄 */

void check_pvd_status(void);

static void idle_hook(void)
{
    check_pvd_status();
    /* 在空闲线程的回调函数里喂狗 */
    if(!_use_console)
    rt_device_control(wdg_dev, RT_DEVICE_CTRL_WDT_KEEPALIVE, NULL);
}

static int iwdg_start(int tmo)
{
    rt_err_t ret = RT_EOK;
    rt_uint32_t timeout = 4000;    /* 溢出时间 */

    /* 根据设备名称查找看门狗设备，获取设备句柄 */
    wdg_dev = rt_device_find(IWDG_DEVICE_NAME);
    if (!wdg_dev)
    {
        rt_kprintf("find %s failed!\n", IWDG_DEVICE_NAME);
        return RT_ERROR;
    }
    /* 初始化设备 */
    ret = rt_device_init(wdg_dev);
    if (ret != RT_EOK)
    {
        rt_kprintf("initialize %s failed!\n", IWDG_DEVICE_NAME);
        return RT_ERROR;
    }
    /* 设置看门狗溢出时间 */
    ret = rt_device_control(wdg_dev, RT_DEVICE_CTRL_WDT_SET_TIMEOUT, &timeout);
    if (ret != RT_EOK)
    {
        rt_kprintf("set %s timeout failed!\n", IWDG_DEVICE_NAME);
        return RT_ERROR;
    }
    /* 设置空闲线程回调函数 */
    // rt_device_control(wdg_dev, RT_DEVICE_CTRL_WDT_KEEPALIVE, NULL);
    rt_thread_idle_sethook(idle_hook);
    rt_kprintf("start iwd!\n ");
    return ret;
}
#endif
extern int is_iwdrst();

static int query_charging_record_cb(transaction *r)
{
    /*将正在充电的订单状态修正为已完成，充电结束原因为断电结束*/
    log_i("rid:%d,cid:%d,user:%s,st:%d,et:%d,sync:%d",r->record_id,r->connector,r->user,r->start_time,r->stop_time,r->sync_flag);
    r->stop_reason = STOP_POWEROFF;
    r->state = CS_CHARGE_FINISH;
    update_history_record(r);
    return 0;
}

void set_default_mac(void)
{
    uint32_t CpuID[3];
    uint32_t Lock_Code;    
    char mac[20];
    //获取CPU唯一ID
    CpuID[0]=*(uint32_t*)(0x1ffff7e8);
    CpuID[1]=*(uint32_t*)(0x1ffff7ec);
    CpuID[2]=*(uint32_t*)(0x1ffff7f0);
    //加密算法,很简单的加密算法
    Lock_Code=(CpuID[0]>>1)+(CpuID[1]>>2)+(CpuID[2]>>3);
    //printf("id:%08X, %08X, %08X, code:%08X\n", CpuID[0],CpuID[1],CpuID[2],Lock_Code);
    if(!get_config("mac")) {
        sprintf(mac,"00-E0-81-%02X-%02X-%02X", (Lock_Code>>16)&0xFF,(Lock_Code>>8)&0xFF,(Lock_Code)&0xFF);
        /*50-E0-85 联想X1 LAN MAC*/
        // sprintf(mac,"50-E0-85-%02X-%02X-%02X", (Lock_Code>>16)&0xFF,(Lock_Code>>8)&0xFF,(Lock_Code)&0xFF);
        set_config("mac", mac);
    }
}
#ifdef GPKG_USING_WIZNET
extern int wiz_init(void);
#endif

#ifdef USING_HM_PLC
int get_rssi(void)
{
    return 0;
}
char *get_iccid(void)
{
    return NULL;
}
#endif

#if defined(USING_CCM_C1X) || defined(USING_CCM_C5X) || defined(USING_CCM_C7X) || defined(USING_CCM_SIMULATOR)
typedef void(*ui_poll)(time_t now);
typedef void (*ui_init)(const char *path, int baudrate);

struct ui_ops
{
    const char *name;
    ui_init init;
    ui_poll poll;
};

extern void ui_com_init_t5(const char *path, int baudrate);
extern void ui_com_poll_t5(time_t now);
extern void ui_com_init_t53(const char *path, int baudrate);
extern void ui_com_poll_t53(time_t now);
extern void ui_com_init_dgus(const char *path, int baudrate);
extern void ui_com_poll_dgus(time_t now);
extern void ui_com_init_dgus_jyt(const char *path, int baudrate);
extern void ui_com_poll_dgus_jyt(time_t now);
extern void ui_com_init_dgus2(const char *path, int baudrate);
extern void ui_com_poll_dgus2(time_t now);
extern void ui_com_init_t5bgc(const char *path, int baudrate);
extern void ui_com_poll_t5bgc(time_t now);
extern void ui_com_init_t5js(const char *path, int baudrate);
extern void ui_com_poll_t5js(time_t now);
extern void ui_com_init_dgusx(const char *path, int baudrate);
extern void ui_com_poll_dgusx(time_t now);
extern void ui_com_init_dgusx_js(const char *path, int baudrate);
extern void ui_com_poll_dgusx_js(time_t now);

static const struct ui_ops ui_ops_tab[] = 
{
#ifdef UI_USING_T5_4827_STD    
    {"t5",      ui_com_init_t5      ,ui_com_poll_t5},
#endif    
#ifdef UI_USING_T5_3224_STD
    {"t53",     ui_com_init_t53     ,ui_com_poll_t53},
#endif
#ifdef UI_USING_DGUS
    {"dgus",    ui_com_init_dgus    ,ui_com_poll_dgus},
#endif
#ifdef UI_USING_DGUS_JYT
    {"dgus",    ui_com_init_dgus_jyt    ,ui_com_poll_dgus_jyt},
#endif
#ifdef UI_USING_DGUS2
    {"dgus2",   ui_com_init_dgus2   ,ui_com_poll_dgus2},
#endif
#ifdef UI_USING_T5_BGC
    {"t5bgc",   ui_com_init_t5bgc   ,ui_com_poll_t5bgc},
#endif
#ifdef UI_USING_T5_4827_JS   
    {"t5js",    ui_com_init_t5js    ,ui_com_poll_t5js},
#endif   
#ifdef UI_USING_DGUSX
    {"dgusx",    ui_com_init_dgusx    ,ui_com_poll_dgusx},
#endif
#ifdef UI_USING_DGUSX_JS
    {"dgusxjs",    ui_com_init_dgusx_js    ,ui_com_poll_dgusx_js},
#endif
};

static ui_poll _fn_ui_poll=NULL;

void ui_com_init(const char *path, int baudrate)
{
    const char *val;
    int i;
#ifdef USING_C2_V200 /*C2默认dgus屏*/
    val = get_config_str("ui", "dgus");
#else 
    val = get_config_str("ui", "t5");
#endif
    for(i=0; i<sizeof(ui_ops_tab)/sizeof(struct ui_ops); i++)
    {
        /*从支持的屏列表寻找当前配置屏*/
        if(strcmp(val, ui_ops_tab[i].name)==0) 
        {
            ui_ops_tab[i].init(path, baudrate);
            _fn_ui_poll = ui_ops_tab[i].poll;
            break;
        }
    }
    /*如果屏列表大于0，且上面没有找到配置屏，直接初始化为屏列表中最后一项*/
    if(i>0 && i==sizeof(ui_ops_tab)/sizeof(struct ui_ops))
    {
        ui_ops_tab[i-1].init(path, baudrate);
        _fn_ui_poll = ui_ops_tab[i-1].poll;
    }
}

void ui_com_poll(time_t now)
{
    if(_fn_ui_poll)
        _fn_ui_poll(now);
}

#endif
#if 0
int main(void)
{
    time_t now;
    int size;
    // g_set_time(1584071150);
    extern int open_dev();
    extern int can_write_data();
    open_dev();
    while (1)
    {
        now = time(NULL);
        rt_thread_mdelay(1000);
        // size = can_write_data();
        // rt_kprintf("size :%d\n",size);
    }
}
#endif
# if 1

#ifdef SONGLI_DEFAULT
static void set_songli_default_value()
{
    const char *val;
    val = get_config("bk");
    if(!val)
    {
        set_config("bk","goiot");
    }

    val = get_config("server");
    if(!val)
    {
        set_config("server","tcp://mqtt-cn-0pp0tx89t05.mqtt.aliyuncs.com:1883");
    }

    val = get_config("topic_pre");
    if(!val)
    {
        set_config("topic_pre","sonli_prod/rd");
    }

    val = get_config("clientid_pre");
    if(!val)
    {
        set_config("clientid_pre","GID_prod_charge@@@");
    }

    val = get_config("r_user");
    if(!val)
    {
        set_config("r_user","LTAIcFifUytOrIbR");
    }
    val = get_config("r_password");
    if(!val)
    {
        set_config("r_password","7W+KMhoJrWsBHaILi9Yk3xxz7wg=");
    }

    val = get_config("show_balance");
    if(!val)
    {
        set_config("show_balance","0");
    }

    val = get_config("stopped_notify");
    if(!val)
    {
        set_config("stopped_notify","1");
    }
}
#endif
static int app(int argc, char *argv[]);

extern int dfs_mkfs(const char *fs_name, const char *device_name);

int check_fds_broken()
{
    int size;
    char buffer[10]={0};
    FILE *f = fopen("test.txt", "rb");
    if(!f) 
    {
        f = fopen("test.txt", "wb");
        if(!f) goto mkfs_exit;
        fwrite("Hello\r\n", 1, 7, f);
        fclose(f);

        f = fopen("test.txt", "rb");
        if(!f) goto mkfs_exit;
    }
    fseek(f, 0, SEEK_SET);
    fread(buffer, 1, 5, f);
    log_i("%s",buffer);
    fclose(f);
    if(strncmp(buffer, "Hello", 5)) goto mkfs_exit;
    log_i("check file system sucess!");
    return 0;
mkfs_exit:
    log_e("check file sytem failed! remake file system!");
    dfs_mkfs("elm", "elm0");
    return -1;
}

#define STARTADDR 0x08000000
int ReadFlashNByte(uint32_t ReadAddress, uint8_t *ReadBuf, int32_t ReadNum)
{
    int DataNum = 0;
    ReadAddress = (uint32_t)STARTADDR+ReadAddress;
    while(DataNum<ReadNum)
    {
        *(ReadBuf+DataNum)=*(uint8_t*)ReadAddress++;
        DataNum++;
    }

    return DataNum;
}

#include <stm32f1xx.h>

static int read_from_flash(long offset, uint8_t *buf, size_t size)
{
    size_t i;
    uint32_t addr = STARTADDR + offset;
    for (i = 0; i < size; i++, addr++, buf++)
    {
        *buf = *(uint8_t *) addr;
    }

    return size;
}

#if 1
static int write_to_flash(long offset, const uint8_t *buf, size_t size)
{
    // size_t i;
    // uint32_t read_data;
    // uint32_t addr = STARTADDR + offset;

    uint16_t my_add = 0x0001;
    uint32_t Robot_Num_Flash_Add = 0x08003fa0;
    uint32_t Robot_Num_Flash_Add1 = 0x08003fb0;

    FLASH_EraseInitTypeDef My_Flash;  //声明 FLASH_EraseInitTypeDef 结构体为 My_Flash
    HAL_FLASH_Unlock();               //解锁Flash
    My_Flash.TypeErase = FLASH_TYPEERASE_PAGES;  //标明Flash执行页面只做擦除操作
    My_Flash.PageAddress = Robot_Num_Flash_Add;  //声明要擦除的地址
    My_Flash.NbPages = 1;              //说明要擦除的页数，此参数必须是Min_Data = 1和Max_Data =(最大页数-初始页的值)之间的值
    
    uint32_t PageError = 0;            //设置PageError,如果出现错误这个变量会被设置为出错的FLASH地址
    HAL_FLASHEx_Erase(&My_Flash, &PageError);  //调用擦除函数擦除

    //uint16_t Write_Flash_Data = 0x0001;
    uint64_t *num = buf;//0x0123456789abcdef;
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Robot_Num_Flash_Add1, *num); //对Flash进行烧写
    //my_add = 0x0002;
    //HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, Robot_Num_Flash_Add1, my_add); //对Flash进行烧写

    HAL_FLASH_Lock(); //锁住Flash

    return size;
}

static int write_to_flash2(long offset, uint32_t num)
{
    uint16_t my_add = 0x0001;
    uint32_t Robot_Num_Flash_Add = 0x08003fa0;
    uint32_t Robot_Num_Flash_Add1 = 0x08003fb0;

    FLASH_EraseInitTypeDef My_Flash;  //声明 FLASH_EraseInitTypeDef 结构体为 My_Flash
    HAL_FLASH_Unlock();               //解锁Flash
    My_Flash.TypeErase = FLASH_TYPEERASE_PAGES;  //标明Flash执行页面只做擦除操作
    My_Flash.PageAddress = Robot_Num_Flash_Add;  //声明要擦除的地址
    My_Flash.NbPages = 1;              //说明要擦除的页数，此参数必须是Min_Data = 1和Max_Data =(最大页数-初始页的值)之间的值
    
    uint32_t PageError = 0;            //设置PageError,如果出现错误这个变量会被设置为出错的FLASH地址
    HAL_FLASHEx_Erase(&My_Flash, &PageError);  //调用擦除函数擦除

    //uint16_t Write_Flash_Data = 0x0001;
    //uint64_t *num = buf;//0x0123456789abcdef;
    //HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Robot_Num_Flash_Add1, *num); //对Flash进行烧写
    //my_add = 0x0002;
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Robot_Num_Flash_Add, num); //对Flash进行烧写

    HAL_FLASH_Lock(); //锁住Flash

    return 0;
}
#endif


#if 1
///////////////////////////
//duanma start, mengma code
///////////////////////////
#define HT1621_CS       14
#define HT1621_RD       15
#define HT1621_WR       30
#define HT1621_DATA     29
#define MaxSegNum       31 //25
#define COMMAND         0
#define DAT             1

//HT1621指令
#define BIAS		0x52		//1000 0101 0010
#define SYSDIS		0x00		//1000 0000 0000
#define SYSEN		0x02		//1000 0000 0010
#define LCDOFF		0x04		//1000 0000 0100
#define LCDON		0x06		//1000 0000 0110
#define XTAL		0x28		//1000 0010 1000
#define RC256		0x30		//1000 0011 0000
#define	WDTDIS1		0x0A		//1000 0000 1010

#define CL_LINE                         THIS_LINE
#define CL_FUNC                         __func__
#define CL_OK                           0
#define CL_FAIL                         (-1)
#define CL_TRUE                         1
#define CL_FALSE                        0

typedef enum{
	UI_POWERON=0,					//ÉÏµç
	UI_STANDBY,						//´ý»úÒ³
	UI_READING_CRAD,				//¶Á¿¨ÖÐÒ³Ãæ
	UI_READ_CARD_SUCCESS,			//¶Á¿¨³É¹¦
	UI_VERIFY_CARD_FAILURE,			//¿¨Æ¬×´Ì¬Ò³Ãæ
	UI_CARD_CHARGING,				//¸Ã¿¨Æ¬ÓÐ³äµçÖÐ¶©µ¥
	UI_INPUT_SOCKET_NUM,			//ÊäÈë²å×ù±àºÅÒ³Ãæ
	UI_INPUT_CHARGER_MONEY,			//ÊäÈë½ð¶îÒ³Ãæ
	UI_SOCKET_OCCUPY,				//²å×ù±»Õ¼ÓÃÒ³Ãæ
	UI_SOCKET_EXCEPTION,			//²å×ù¹ÊÕÏÒ³Ãæ
	UI_SOCKET_NOT_EXSIT,			//²å×ã±àºÅ²»´æÔÚÒ³Ãæ
	UI_START_CHARGING,				//¿ªÆô³äµçÖÐÒ³Ãæ
	UI_START_PAYMENT_CARD_CHARGING,				//Ö§¸¶¿¨¿ªÆô³äµçÖÐ½çÃæ
	UI_CARD_MONEY_INSUFFICIENT,		//¿¨Óà¶î²»×ãÒ³Ãæ
	UI_PAYMENT_CARD_MONEY_INSUFFICIENT,		//zfk???????
	UI_CHARGING,					//³äµçÖÐÒ³Ãæ
	UI_START_CHARGING_FAILURE,		//¿ªÆô³äµçÊ§°ÜÒ³Ãæ
	UI_OVER_POWER,					//¹¦ÂÊ¹ý´ó
	UI_EQUIP_OFFLINE_EXCEPTION,		//Éè±¸ÀëÏß»ò¹ÊÕÏ
	UI_EQUIP_UPGRADE,				//Éè±¸Éý¼¶
	UI_ADMINISTRATOR_TEST,			//¹ÜÀíÔ±²âÊÔÄ£Ê½Ò³Ãæ
	UI_INPUT_CHARGER_SN,			//ÊäÈë×®ºÅÒ³Ãæ
	UI_INPUT_DEVICE_ID,				//ÊäÈëÊ¶±ðÂëÒ³Ãæ
	UI_SET_PRINT_SWITCH,            //ÉèÖÃÀ¶ÑÀmacµØÖ·
	UI_RELAY_TEST,					//¼ÌµçÆ÷²âÊÔ
	UI_EVENT_NOTICE_TEST,			//ÊÂ¼þÍ¨ÖªÉÏ±¨²âÊÔ
	UI_VOICE_BROADCAST_TEST,		//ÓïÒô²¥±¨²âÊÔ
	UI_SHOW_SIGNAL,					//ÐÅºÅÖµÏÔÊ¾
	UI_LCD_TEST,					//Òº¾§ÆÁ²âÊÔ
	UI_PRODUCT_TEST,				//Éú²ú²âÊÔ
	UI_MAX,
}UI_STATE;

typedef struct key_values{
	char inputStr[16];
	int inputLen ;
}KEY_VALUES;


typedef struct{
	UI_STATE Ui_State;
	uint32_t uiStartTime;
}ui_info_t;


typedef enum{
	LCD_CLEAR = 0,			//Çå³ý
	LCD_DISPLAY = 1,		//ÏÔÊ¾
}LCD_Display_TypeDef;


typedef enum{
	SEG0_SOCKET_FAULT 		= 0X04,//¹ÊÕÏ
	SEG0_INVALID 			= 0X08,//ÎÞÐ§ //勘误 原来是0x04
	SEG0_FAILURE			= 0x01,//Ê§°Ü
	SEG0_SUCCESS	  		= 0x02,//勘误
}SEG0_DISPLAY_t;

typedef enum{
	SEG1_PROGRESS_BAR4 		= 0x08,	//½ø¶ÈÌõT4
	SEG1_PROGRESS_BAR3   	= 0x04,	//½ø¶ÈÌõT3
	SEG1_PROGRESS_BAR2 		= 0x02,	//½ø¶ÈÌõT2
	SEG1_PROGRESS_BAR1		= 0x01,	//½ø¶ÈÌõT1
}SEG1_DISPLAY_t;

typedef enum{
    SEG2_YUAN               = 0x08, //勘误
	SEG2_SOCKET_CHARGING	= 0x08,	//³äµçÖÐ
	SEG2_SOCKET_IDLE		= 0x04,	//¿ÕÏÐ
	SEG2_SOCKET_OCCUPIED 	= 0x02,	//Õ¼ÓÃ
	SEG2_SUCCESS	  		= 0x01, //³É¹¦
}SEG2_DISPLAY_t;

typedef enum{
	SEG3_YUAN				= 0x08,//Ôª
	SEG3_10C   				= 0x04,//10C
	SEG3_10G 				= 0x02,//10G
	SEG3_10B  				= 0x01,//10B
}SEG3_DISPLAY_t;

typedef enum{
	SEG4_10D				= 0x08,//10D
	SEG4_10E   				= 0x04,//10E
	SEG4_10F				= 0x02,//10F
	SEG4_10A				= 0x01,//10A
}SEG4_DISPLAY_t;

typedef enum{
	SEG5_DP3 				= 0x08,//Ð¡ÊýµãDP3
	SEG5_9C   				= 0x04,//9C
	SEG5_9G 				= 0x02,//9G
	SEG5_9B					= 0x01,//9B
}SEG5_DISPLAY_t;

typedef enum{
	SEG6_9D 				= 0x08,//9D
	SEG6_9E   				= 0x04,//9E
	SEG6_9F 				= 0x02,//9F
	SEG6_9A					= 0x01,//9A
}SEG6_DISPLAY_t;

typedef enum{
	SEG7_DP2 				= 0x08,//Ð¡ÊýµãDP2
	SEG7_8C   				= 0x04,//8C
	SEG7_8G 				= 0x02,//8G
	SEG7_8B					= 0x01,//8B
}SEG7_DISPLAY_t;

typedef enum{
	SEG8_8D 				= 0x08,//8D
	SEG8_8E   				= 0x04,//8E
	SEG8_8F 				= 0x02,//8F
	SEG8_8A					= 0x01,//8A
}SEG8_DISPLAY_t;

typedef enum{
	SEG9_DP1 				= 0x08,//Ð¡ÊýµãDP1
	SEG9_7C   				= 0x04,//7C
	SEG9_7G 				= 0x02,//7G
	SEG9_7B					= 0x01,//7B
}SEG9_DISPLAY_t;

typedef enum{
	SEG10_7D 				= 0x08,//7D
	SEG10_7E   				= 0x04,//7E
	SEG10_7F 				= 0x02,//7F
	SEG10_7A				= 0x01,//7A
}SEG10_DISPLAY_t;

typedef enum{
	SEG10_PRE 				= 0x08,//7D
	SEG10_CHG  				= 0x04,//7E
	SEG10_KW 				= 0x02,//7F
	SEG10_A				    = 0x01,//7A
}SEG10X_DISPLAY_t;

typedef enum{
	SEG11_NOSIGNAL 			= 0x08,//ÎÞÐÅºÅ
	SEG11_SIGNAL   			= 0x04,//ÓÐÐÅºÅ
	SEG11_BACKSTAGE_CONNECT = 0x02,//ºóÌ¨Á¬½Ó·ûºÅ
	SEG11_CHARGE_METHOD		= 0x01,//ÇëË¢¿¨»òÉ¨Âë¿ªÆô³äµç
}SEG11_DISPLAY_t;

typedef enum{
	SEG12_CLOCK_DIAL		= 0x08,//Ê±ÖÓ±íÅÌ
	SEG12_1E   				= 0x04,//1E
	SEG12_1G 				= 0x02,//1G
	SEG12_1F				= 0x01,//1F
}SEG12_DISPLAY_t;

typedef enum{
	SEG13_1D				= 0x08,//1D
	SEG13_1C   				= 0x04,//1C
	SEG13_1B 				= 0x02,//1B
	SEG13_1A				= 0x01,//1A
}SEG13_DISPLAY_t;

typedef enum{
	SEG14_REMAINING_TIME	= 0x08,//Ê£ÓàÊ±³¤
	SEG14_2E   				= 0x04,//2E
	SEG14_2G 				= 0x02,//2G
	SEG14_2F				= 0x01,//2F
}SEG14_DISPLAY_t;

typedef enum{
	SEG15_2D				= 0x08,//2D
	SEG15_2C   				= 0x04,//2C
	SEG15_2B 				= 0x02,//2B
	SEG15_2A				= 0x01,//2A
}SEG15_DISPLAY_t;

typedef enum{
	SEG16_COL1				= 0x08,//Ã°ºÅ1
	SEG16_3E   				= 0x04,//3E
	SEG16_3G 				= 0x02,//3G
	SEG16_3F				= 0x01,//3F
}SEG16_DISPLAY_t;

typedef enum{
	SEG17_3D				= 0x08,//3D
	SEG17_3C   				= 0x04,//3C
	SEG17_3B 				= 0x02,//3B
	SEG17_3A				= 0x01,//3A
}SEG17_DISPLAY_t;

typedef enum{
	SEG18_V   				= 0x08,//4E
	SEG18_4E   				= 0x04,//4E
	SEG18_4G 				= 0x02,//4G
	SEG18_4F				= 0x01,//4F
}SEG18_DISPLAY_t;

typedef enum{
	SEG19_4D				= 0x08,//4D
	SEG19_4C   				= 0x04,//4C
	SEG19_4B 				= 0x02,//4B
	SEG19_4A				= 0x01,//4A
}SEG19_DISPLAY_t;

typedef enum{
	SEG20_COL2				= 0x08,//Ã°ºÅ2
	SEG20_5E   				= 0x04,//5E
	SEG20_5G 				= 0x02,//5G
	SEG20_5F				= 0x01,//5F
}SEG20_DISPLAY_t;

typedef enum{
	SEG21_5D				= 0x08,//5D
	SEG21_5C   				= 0x04,//5C
	SEG21_5B 				= 0x02,//5B
	SEG21_5A				= 0x01,//5A
}SEG21_DISPLAY_t;

typedef enum{
	SEG22_BLUTOOTH			= 0x08,//À¶ÑÀ·ûºÅ
	SEG22_6E   				= 0x04,//6E
	SEG22_6G 				= 0x02,//6G
	SEG22_6F				= 0x01,//6F
}SEG22_DISPLAY_t;

typedef enum{
	SEG23_6D				= 0x08,//6D
	SEG23_6C   				= 0x04,//6C
	SEG23_6B 				= 0x02,//6B
	SEG23_6A				= 0x01,//6A
}SEG23_DISPLAY_t;

typedef enum{
	SEG24_EDGE				= 0x08,//±ßÔµ
	SEG24_TAB1_EDGE   		= 0x04,//TAB1±ßÔµ
	SEG24_TAB2_EDGE			= 0x02,//TAB2±ßÔµ
	SEG24_TAB3_EDGE			= 0x01,//TAB3±ßÔµ
}SEG24_DISPLAY_t;

typedef enum{
	SEG25_NUM				= 0x08,//ºÅ
	SEG25_CARD_BALANCE   	= 0x04,//¿¨Æ¬Óà¶î
	SEG25_SOCKET_NUM 		= 0x02,//²å×ù±àºÅ
	SEG25_CHARING_MONEY		= 0x01,//³äµç½ð¶î
}SEG25_DISPLAY_t;


typedef enum{
	FIRST = 1,
	SECOND = 2,
	THIRD = 3,
	FOURTH = 4,
	FIFTH = 5,
	SIXTH = 6,
	SEVENTH = 7,
	EIGHTH = 8,
	NINTH = 9,
	TEN = 10,
	ELEVENTH = 11,
}DATA_POS_t;

/*******************************函数定义**************************/
int LinuxTickToDay(time_t timestamp, uint8_t *pDay)
{
    struct tm *time_now;

	time_now = localtime(&timestamp);
    pDay[0] = time_now->tm_wday;
    pDay[1] = time_now->tm_year-100;
    pDay[2] = time_now->tm_mon+1;
    pDay[3] = time_now->tm_mday;
    pDay[4] = time_now->tm_hour;
    pDay[5] = time_now->tm_min;
    pDay[6] = time_now->tm_sec;
	
    return CL_OK;
}

void GetRtcTime(time_t time, void* pRTCTime)
{
    //uint32_t time = 0;
    //time = rtc_counter_get();
    time += 8*60*60; //东八区时间
    LinuxTickToDay(time,pRTCTime);
}



//lcd显示时间
void UiDisplay_Time(uint8_t hour, uint8_t min, uint8_t sec)
{
	uint8_t tmp = 0;

	tmp = hour/10;
	UiDisplay_PosData(1, tmp);
	tmp = hour%10;
	UiDisplay_PosData(2, tmp);
	tmp = min/10;
	UiDisplay_PosData(3, tmp);
	tmp = min%10;
	UiDisplay_PosData(4, tmp);
	tmp = sec/10;
	UiDisplay_PosData(5, tmp);
	tmp = sec%10;
	UiDisplay_PosData(6, tmp);
	LcdDisplayCol((DATA_POS_t)1, LCD_DISPLAY);
	LcdDisplayCol((DATA_POS_t)2, LCD_DISPLAY);
}



void Ht1621_WR_1(void)
{
	rt_pin_write(HT1621_WR, PIN_HIGH);//gpio_bit_set(LCD_WRN_GPIO, LCD_WRN_PIN);
}

void Ht1621_WR_0(void)
{
	rt_pin_write(HT1621_WR, PIN_LOW);//gpio_bit_reset(LCD_WRN_GPIO, LCD_WRN_PIN);
}

void Ht1621_RD_1(void)
{
	rt_pin_write(HT1621_RD, PIN_HIGH);//gpio_bit_set(LCD_RDN_GPIO, LCD_RDN_PIN);
}

void Ht1621_RD_0(void)
{
	rt_pin_write(HT1621_RD, PIN_LOW);//gpio_bit_reset(LCD_RDN_GPIO, LCD_RDN_PIN);
}

void Ht1621_CS_1(void)
{
	rt_pin_write(HT1621_CS, PIN_HIGH);//gpio_bit_set(LCD_CS_GPIO, LCD_CS_PIN);
}

void Ht1621_CS_0(void)
{
	rt_pin_write(HT1621_CS, PIN_LOW);//gpio_bit_reset(LCD_CS_GPIO, LCD_CS_PIN);
}

void Ht1621_DATA_1(void)
{
	rt_pin_write(HT1621_DATA, PIN_HIGH);//gpio_bit_set(LCD_DATA_GPIO, LCD_DATA_PIN);
}

void Ht1621_DATA_0(void)
{
	rt_pin_write(HT1621_DATA, PIN_LOW);//gpio_bit_reset(LCD_DATA_GPIO, LCD_DATA_PIN);
}

void Ht1621LightOn(void)
{
	//gpio_bit_set(LCD_LIGHT_GPIO, LCD_LIGHT_PIN);
}

void Ht1621LightOff(void)
{	
	//gpio_bit_reset(LCD_LIGHT_GPIO, LCD_LIGHT_PIN);
}

uint8_t Ht1621GetDataPortVal(void)
{	
	return rt_pin_read(HT1621_DATA);//gpio_input_bit_get(LCD_DATA_GPIO, LCD_DATA_PIN);
}


/**
***Ht1621 写数据函数时序
***Data: 要发送的数据，cnt:要发送的数据位
**/
void Ht1621Wr_Data(uint8_t Data, uint8_t cnt)
{
	uint8_t i=0;
	rt_pin_mode(HT1621_DATA, PIN_MODE_OUTPUT);//gpio_init(LCD_DATA_GPIO, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, LCD_DATA_PIN);
	
	for (i=0; i<cnt; i++) {
		Ht1621_WR_0();
    delay_nop(10);
		if ((Data & 0x80)==0x80) {
			Ht1621_DATA_1();
		} else {
			Ht1621_DATA_0();
		}
		Ht1621_WR_1();
    delay_nop(10);
		Data<<=1;	
	}
}
/**
***Ht1621读某段所映射地址存储数据内容的时序(D0-D3)
***
**/
uint8_t Ht1621Rd_Data(void)
{
	uint8_t SegVal=0;
	rt_pin_mode(HT1621_DATA, PIN_MODE_INPUT);//gpio_init(LCD_DATA_GPIO, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, LCD_DATA_PIN);
	Ht1621_WR_1();
	__NOP();
	__NOP();
	__NOP();
	for (uint8_t i=0; i<4; i++) {
		Ht1621_RD_0();
		if (1 == Ht1621GetDataPortVal()) {
			SegVal |= (0x08>>i);
		} else {
			SegVal |= (0x0>>i);
		}
		__NOP();
	    __NOP();
	__NOP();
		Ht1621_RD_1();
		__NOP();
	__NOP();
	__NOP();
	}
	
	return SegVal;
}

/**
***Ht1621写指令函数时序
***
**/
void Ht1621WrCmd(uint8_t cmd)
{
	Ht1621_CS_0();
	__NOP();
	Ht1621Wr_Data(0x80, 4);			//写入命令标志100
	Ht1621Wr_Data(cmd, 8);			//写入命令数据
	
	Ht1621_CS_1();
	__NOP();
}

/**
***Ht1621读取段的值时序
***
**/
uint8_t Ht1621ReadSegVal(uint8_t segAddr) 
{
	uint8_t segVal = 0;;
	
	Ht1621_CS_0();
	__NOP();
	__NOP();
	__NOP();
	Ht1621_RD_1();
	__NOP();
	Ht1621Wr_Data(0xC0, 3);			//写入命令标志110
	__NOP();
	Ht1621Wr_Data(segAddr<<2, 6);	//写入地址(A5-A0)
	
	segVal = Ht1621Rd_Data();
	Ht1621_CS_1();
	__NOP();
	return segVal;
}

/**
***Ht1621写一个数据函数
***
**/
void delay_nop(int cnt)
{
    for(int i=0; i<cnt; i++)
    {
        __NOP();
    }
}
void Ht1621WriteSegVal(uint8_t segAddr, uint8_t val)
{
	Ht1621_CS_0();
    delay_nop(10);
	Ht1621Wr_Data(0xa0, 3);			    //写入数据标志101
    delay_nop(10);
	Ht1621Wr_Data(segAddr<<2, 6);		//写入地址数据(A5-A0)
    delay_nop(10);
	Ht1621Wr_Data(val<<4, 4);			//写入数据的后4位
    delay_nop(10);
	Ht1621_CS_1();
    delay_nop(10);

}

/**
***Ht1621写全屏数据
***
**/
void Ht1621WriteAllSegVal(uint8_t *p, uint8_t cnt)
{
	uint8_t i = 0;
	
	Ht1621_CS_0();
	
	Ht1621Wr_Data(0xa0, 3);			//写入数据标志101
	Ht1621Wr_Data(0<<2, 6);			//写入地址数据Seg0地址
	for (i=0; i<cnt; i++) {
		Ht1621Wr_Data(*p, 8);		//写入数据
		p++;
	}
	
	Ht1621_CS_1();
	__NOP();
}

void LcdTurnOnLed(void)
{
	rt_kprintf("turn on led.\n");
	Ht1621LightOn();
}

void LcdTurnOffLed(void)
{
    rt_kprintf("turn off led.\n");
	Ht1621LightOff();
}

void LcdAllOn(void)
{
	uint8_t i=0;

	for(i=0; i<=MaxSegNum; i++){
		Ht1621WriteSegVal(i, 0xFF);
        rt_thread_mdelay(3*1000);
	}
}

void LcdAllOff(void)
{
	uint8_t i=0;

	for(i=0; i<=MaxSegNum; i++){
		Ht1621WriteSegVal(i, 0x00);
	}
}

void LcdDisplay(uint8_t seg, uint8_t segVal, LCD_Display_TypeDef displayFlg)
{
	uint8_t lcdBuf = 0;
	lcdBuf = Ht1621ReadSegVal(seg);
	if (LCD_DISPLAY == displayFlg) {
		lcdBuf |= segVal;
	} else {
		lcdBuf &= ~segVal;
	}
	Ht1621WriteSegVal(seg, lcdBuf);
}


void LcdDisplayBackStageConnect(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(11, SEG11_BACKSTAGE_CONNECT, displayFlg);
}

void LcdDisplaySingnal(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(11, SEG11_SIGNAL, displayFlg);
}

void LcdDisplayNoSingnal(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(11, SEG11_NOSIGNAL, displayFlg);
}

void LcdDisplayBlutooth(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(22, SEG22_BLUTOOTH, displayFlg);
}

void LcdDisplayChgMethod(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(11, SEG11_CHARGE_METHOD, displayFlg);
}

void LcdDisplaySuccess(LCD_Display_TypeDef displayFlg)
{
	//LcdDisplay(2, SEG2_SUCCESS, displayFlg); //勘误
	LcdDisplay(0, SEG0_SUCCESS, displayFlg);
}

void LcdDisplayFailure(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(0, SEG0_FAILURE, displayFlg);
}

void LcdDisplayProgressBar1(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(1, SEG1_PROGRESS_BAR1, displayFlg);
}

void LcdDisplayProgressBar2(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(1, SEG1_PROGRESS_BAR2, displayFlg);
}

void LcdDisplayProgressBar3(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(1, SEG1_PROGRESS_BAR3, displayFlg);
}

void LcdDisplayProgressBar4(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(1, SEG1_PROGRESS_BAR4, displayFlg);
}

void LcdDisplayChargeing(LCD_Display_TypeDef displayFlg)
{
	//LcdDisplay(2, SEG2_SOCKET_CHARGING, displayFlg);
	LcdDisplay(10, SEG10_PRE, displayFlg);
}

void LcdDisplaySocketIdle(LCD_Display_TypeDef displayFlg)
{
	//LcdDisplay(2, SEG2_SOCKET_IDLE, displayFlg);
	LcdDisplay(10, SEG10_CHG, displayFlg);
}

void LcdDisplayInvalid(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(0, SEG0_INVALID, displayFlg);
}

void LcdDisplayKW(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(10, SEG10_KW, displayFlg);
}

void LcdDisplayA(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(10, SEG10_A, displayFlg);
}

void LcdDisplayV(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(18, SEG18_V, displayFlg);
}

void LcdDisplaySocketOccupied(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(2, SEG2_SOCKET_OCCUPIED, displayFlg);
}

void LcdDisplaySocketFault(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(0, SEG0_SOCKET_FAULT, displayFlg);
}

void LcdDisplayCardBalance(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(25, SEG25_CARD_BALANCE, displayFlg);
}

void LcdDisplaySocketNum(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(25, SEG25_SOCKET_NUM, displayFlg);
}

void LcdDisplayChargeingMoney(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(25, SEG25_CHARING_MONEY, displayFlg);
}


void LcdDisplayEdge(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(24, SEG24_EDGE, displayFlg);
}

void LcdDisplayTab1Edge(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(24, SEG24_TAB1_EDGE, displayFlg);
}

void LcdDisplayTab2Edge(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(24, SEG24_TAB2_EDGE, displayFlg);
}

void LcdDisplayTab3Edge(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(24, SEG24_TAB3_EDGE, displayFlg);
}

void LcdDisplayH(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(25, SEG25_NUM, displayFlg);
}

void LcdDisplayYuan(LCD_Display_TypeDef displayFlg)
{
	//LcdDisplay(3, SEG3_YUAN, displayFlg);
	LcdDisplay(2, SEG2_YUAN, displayFlg); //勘误
}

void LcdDisplayRemainingTime(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(14, SEG14_REMAINING_TIME, displayFlg);
}

void LcdDisplayClockDial(LCD_Display_TypeDef displayFlg)
{
	LcdDisplay(12, SEG12_CLOCK_DIAL, displayFlg);
}

void LcdClrData(DATA_POS_t pos)
{
	uint8_t segValue = 0;
	switch(pos){
		case FIRST:
			Ht1621WriteSegVal(13, 0x00);
			segValue = SEG12_1E|SEG12_1F|SEG12_1G;
			LcdDisplay(12, segValue, LCD_CLEAR);
			break;

		case SECOND:
			Ht1621WriteSegVal(15, 0x00);
			segValue = SEG14_2E|SEG14_2G|SEG14_2F;
			LcdDisplay(14, segValue, LCD_CLEAR);
			break;

		case THIRD:
			Ht1621WriteSegVal(17, 0x00);
			segValue = SEG16_3E|SEG16_3G|SEG16_3F;
			LcdDisplay(16, segValue, LCD_CLEAR);
			break;

		case FOURTH:	
			Ht1621WriteSegVal(19, 0x00);
			segValue = SEG18_4E|SEG18_4G|SEG18_4F;
			LcdDisplay(18, segValue, LCD_CLEAR);
			break;

		case FIFTH:
			Ht1621WriteSegVal(21, 0x00);
			segValue = SEG20_5E|SEG20_5G|SEG20_5F;
			LcdDisplay(20, segValue, LCD_CLEAR);
			break;

		case SIXTH:
			Ht1621WriteSegVal(23, 0x00);
			segValue = SEG22_6E|SEG22_6G|SEG22_6F;
			LcdDisplay(22, segValue, LCD_CLEAR);
			break;

		case SEVENTH:
			//segValue = Ht1621ReadSegVal(9);
			segValue = Ht1621ReadSegVal(8); //勘误
			segValue = SEG9_7C|SEG9_7G|SEG9_7B;
			LcdDisplay(8, segValue, LCD_CLEAR);
			segValue = 0;
			segValue = SEG10_7D|SEG10_7E|SEG10_7F|SEG10_7A;
			LcdDisplay(9, segValue, LCD_CLEAR);
			break;

		case EIGHTH:
			//segValue = Ht1621ReadSegVal(7);
			segValue = Ht1621ReadSegVal(6); //勘误
			segValue = SEG7_8C|SEG7_8G|SEG7_8B;
			LcdDisplay(6, segValue, LCD_CLEAR);
			segValue = 0;
			segValue = SEG8_8D|SEG8_8E|SEG8_8F|SEG8_8A;
			LcdDisplay(7, segValue, LCD_CLEAR);
			break;

		case NINTH:
			//segValue = Ht1621ReadSegVal(5);
			segValue = Ht1621ReadSegVal(4); //勘误
			segValue = SEG5_9C|SEG5_9G|SEG5_9B;
			LcdDisplay(4, segValue, LCD_CLEAR);
			segValue = 0;
			segValue = SEG6_9D|SEG6_9E|SEG6_9F|SEG6_9A;
			LcdDisplay(5, segValue, LCD_CLEAR);
			break;

		case TEN:
			//segValue = Ht1621ReadSegVal(3);
			segValue = Ht1621ReadSegVal(2); //勘误
			segValue = SEG3_10C|SEG3_10G|SEG3_10B;
			LcdDisplay(2, segValue, LCD_CLEAR);
			segValue = 0;
			segValue = SEG4_10D|SEG4_10E|SEG4_10F|SEG4_10A;
			LcdDisplay(3, segValue, LCD_CLEAR);
			break;
		default:
			break;
	}
}

//ÏÔÊ¾Êý×Ö0	\A\B\C\D\E\F
void LcdDisplayZero(DATA_POS_t pos)
{
	//const uint8_t para0[] = {12,14,16,18,20,22,9,7,5,3};
	const uint8_t para0[] = {12,14,16,18,20,22,8,6,4,2}; //勘误
    const uint8_t para1[] = {SEG12_1E|SEG12_1F,SEG14_2E|SEG14_2F,SEG16_3E|SEG16_3F,SEG18_4E|SEG18_4F,SEG20_5E|SEG20_5F,SEG22_6E|SEG22_6F,SEG9_7B|SEG9_7C,SEG7_8B|SEG7_8C,SEG5_9B|SEG5_9C,SEG3_10B|SEG3_10C};
    const uint8_t para2[] = {SEG13_1A|SEG13_1B|SEG13_1C|SEG13_1D,SEG15_2A|SEG15_2B|SEG15_2C|SEG15_2D,SEG17_3A|SEG17_3B|SEG17_3C|SEG17_3D,SEG19_4A|SEG19_4B|SEG19_4C|SEG19_4D,SEG21_5A|SEG21_5B|SEG21_5C|SEG21_5D,
								SEG23_6A|SEG23_6B|SEG23_6C|SEG23_6D,SEG10_7A|SEG10_7D|SEG10_7E|SEG10_7F,SEG8_8A|SEG8_8D|SEG8_8E|SEG8_8F,SEG6_9A|SEG6_9D|SEG6_9E|SEG6_9F,SEG4_10A|SEG4_10D|SEG4_10E|SEG4_10F};
    uint8_t  index = para0[pos-1];

    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
		Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
		Ht1621WriteSegVal(index+1, para2[pos-1]);
    }
}
//显示数字1 \B\C
void LcdDisplayOne(DATA_POS_t pos)
{
	const uint8_t para0[] = {13,15,17,19,21,23,8,6,4,2};
    const uint8_t para1[] = {SEG13_1B|SEG13_1C,SEG15_2B|SEG15_2C,SEG17_3B|SEG17_3C,SEG19_4B|SEG19_4C,SEG21_5B|SEG21_5C,SEG23_6B|SEG23_6C,SEG9_7B|SEG9_7C,SEG7_8B|SEG7_8C,SEG5_9B|SEG5_9C,SEG3_10B|SEG3_10C};
    
    uint8_t  index = para0[pos-1];
    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
		Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
    }
	
}
//显示数字2 \A\B\D\E\G
void LcdDisplayTwo(DATA_POS_t pos)
{
	const uint8_t para0[] = {12,14,16,18,20,22,8,6,4,2};
    const uint8_t para1[] = {SEG12_1E|SEG12_1G,SEG14_2E|SEG14_2G,SEG16_3E|SEG16_3G,SEG18_4E|SEG18_4G,SEG20_5E|SEG20_5G,SEG22_6E|SEG22_6G,SEG9_7B|SEG9_7G,SEG7_8B|SEG7_8G,SEG5_9B|SEG5_9G,SEG3_10B|SEG3_10G};
    const uint8_t para2[] = {SEG13_1A|SEG13_1B|SEG13_1D,SEG15_2A|SEG15_2B|SEG15_2D,SEG17_3A|SEG17_3B|SEG17_3D,SEG19_4A|SEG19_4B|SEG19_4D,SEG21_5A|SEG21_5B|SEG21_5D,
								SEG23_6A|SEG23_6B|SEG23_6D,SEG10_7A|SEG10_7D|SEG10_7E,SEG8_8A|SEG8_8D|SEG8_8E,SEG6_9A|SEG6_9D|SEG6_9E,SEG4_10A|SEG4_10D|SEG4_10E};
    uint8_t  index = para0[pos-1];

    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
		Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
		Ht1621WriteSegVal(index+1, para2[pos-1]);
    }
}
//显示数字3	\A\B\C\D\G
void LcdDisplayThree(DATA_POS_t pos)
{
	const uint8_t para0[] = {12,14,16,18,20,22,8,6,4,2};
    const uint8_t para1[] = {SEG12_1G,SEG14_2G,SEG16_3G,SEG18_4G,SEG20_5G,SEG22_6G,SEG9_7B|SEG9_7C|SEG9_7G,SEG7_8B|SEG7_8C|SEG7_8G,SEG5_9B|SEG5_9C|SEG5_9G,SEG3_10B|SEG3_10C|SEG3_10G};
    const uint8_t para2[] = {SEG13_1A|SEG13_1B|SEG13_1C|SEG13_1D,SEG15_2A|SEG15_2B|SEG15_2C|SEG15_2D,SEG17_3A|SEG17_3B|SEG17_3C|SEG17_3D,SEG19_4A|SEG19_4B|SEG19_4C|SEG19_4D,SEG21_5A|SEG21_5B|SEG21_5C|SEG21_5D,
								SEG23_6A|SEG23_6B|SEG23_6C|SEG23_6D,SEG10_7A|SEG10_7D,SEG8_8A|SEG8_8D,SEG6_9A|SEG6_9D,SEG4_10A|SEG4_10D};
    uint8_t  index = para0[pos-1];

    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
		Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
		Ht1621WriteSegVal(index+1, para2[pos-1]);
    }
}
//显示数字4	\B\C\F\G
void LcdDisplayFour(DATA_POS_t pos)
{
	LcdClrData(pos);
	switch(pos){
		case FIRST:
			Ht1621WriteSegVal(12, SEG12_1G|SEG12_1F|Ht1621ReadSegVal(12));
			Ht1621WriteSegVal(13, SEG13_1B|SEG13_1C);
			break;

		case SECOND:
			Ht1621WriteSegVal(14, SEG14_2G|SEG14_2F|Ht1621ReadSegVal(14));
			Ht1621WriteSegVal(15, SEG15_2B|SEG15_2C);
			break;

		case THIRD:
			Ht1621WriteSegVal(16, SEG16_3G|SEG16_3F|Ht1621ReadSegVal(16));
			Ht1621WriteSegVal(17, SEG17_3B|SEG17_3C);
			break;

		case FOURTH:
			Ht1621WriteSegVal(18, SEG18_4G|SEG18_4F|Ht1621ReadSegVal(18));
			Ht1621WriteSegVal(19, SEG19_4B|SEG19_4C);
			break;

		case FIFTH:
			Ht1621WriteSegVal(20, SEG20_5G|SEG20_5F|Ht1621ReadSegVal(20));
			Ht1621WriteSegVal(21, SEG21_5B|SEG21_5C);
			break;

		case SIXTH:
			Ht1621WriteSegVal(22, SEG22_6G|SEG22_6F|Ht1621ReadSegVal(22));
			Ht1621WriteSegVal(23, SEG23_6B|SEG23_6C);
			break;

		case SEVENTH:
			Ht1621WriteSegVal(8, SEG9_7B|SEG9_7C|SEG9_7G|Ht1621ReadSegVal(8));
			Ht1621WriteSegVal(9, SEG10_7F);
			break;

		case EIGHTH:
			Ht1621WriteSegVal(6, SEG7_8B|SEG7_8C|SEG7_8G|Ht1621ReadSegVal(6));
			Ht1621WriteSegVal(7, SEG8_8F);
			break;

		case NINTH:
			Ht1621WriteSegVal(4, SEG5_9B|SEG5_9C|SEG5_9G|Ht1621ReadSegVal(4));
			Ht1621WriteSegVal(5, SEG6_9F);
			break;

		case TEN:
			Ht1621WriteSegVal(2, SEG3_10B|SEG3_10C|SEG3_10G|Ht1621ReadSegVal(2));
			Ht1621WriteSegVal(3, SEG4_10F);
			break;
		default:
			break;
	}
}
//显示数字5	\A\C\D\F\G
void LcdDisplayFive(DATA_POS_t pos)
{
	const uint8_t para0[] = {12,14,16,18,20,22,8,6,4,2};
    const uint8_t para1[] = {SEG12_1G|SEG12_1F,SEG14_2G|SEG14_2F,SEG16_3G|SEG16_3F,SEG18_4G|SEG18_4F,SEG20_5G|SEG20_5F,
								SEG22_6G|SEG22_6F,SEG9_7C|SEG9_7G,SEG7_8C|SEG7_8G,SEG5_9C|SEG5_9G,SEG3_10C|SEG3_10G};
    const uint8_t para2[] = {SEG13_1A|SEG13_1C|SEG13_1D,SEG15_2A|SEG15_2C|SEG15_2D,SEG17_3A|SEG17_3C|SEG17_3D,SEG19_4A|SEG19_4C|SEG19_4D,SEG21_5A|SEG21_5C|SEG21_5D,
								SEG23_6A|SEG23_6C|SEG23_6D,SEG10_7A|SEG10_7D|SEG10_7F,SEG8_8A|SEG8_8D|SEG8_8F,SEG6_9A|SEG6_9D|SEG6_9F,SEG4_10A|SEG4_10D|SEG4_10F};
    uint8_t  index = para0[pos-1];

    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
		Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
		Ht1621WriteSegVal(index+1, para2[pos-1]);
    }
}

//显示数字6	\A\C\D\E\F\G
void LcdDisplaySix(DATA_POS_t pos)
{
    const uint8_t para0[] = {12,14,16,18,20,22,8,6,4,2};
    const uint8_t para1[] = {SEG12_1E|SEG12_1F|SEG12_1G,SEG14_2E|SEG14_2F|SEG14_2G,SEG16_3E|SEG16_3F|SEG16_3G,SEG18_4E|SEG18_4F|SEG18_4G,SEG20_5E|SEG20_5F|SEG20_5G,SEG22_6E|SEG22_6F|SEG22_6G,SEG9_7C|SEG9_7G,SEG7_8C|SEG7_8G,SEG5_9C|SEG5_9G,SEG3_10C|SEG3_10G};
    const uint8_t para2[] = {SEG13_1A|SEG13_1C|SEG13_1D,SEG15_2A|SEG15_2C|SEG15_2D,SEG17_3A|SEG17_3C|SEG17_3D,SEG19_4A|SEG19_4C|SEG19_4D,SEG21_5A|SEG21_5C|SEG21_5D,SEG23_6A|SEG23_6C|SEG23_6D,SEG10_7A|SEG10_7D|SEG10_7E|SEG10_7F,SEG8_8A|SEG8_8D|SEG8_8E|SEG8_8F,SEG6_9A|SEG6_9D|SEG6_9E|SEG6_9F,SEG4_10A|SEG4_10D|SEG4_10E|SEG4_10F};
    uint8_t  index = para0[pos-1];

    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
		Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
		Ht1621WriteSegVal(index+1, para2[pos-1]);
    }
}

//显示数字7	\A\B\C
void LcdDisplaySeven(DATA_POS_t pos)
{
    const uint8_t para0[] = {12,14,16,18,20,22,8,6,4,2};
    const uint8_t para1[] = {0,0,0,0,0,0,SEG9_7B|SEG9_7C,SEG7_8B|SEG7_8C,SEG5_9B|SEG5_9C,SEG3_10B|SEG3_10C};
    const uint8_t para2[] = {SEG13_1A|SEG13_1B|SEG13_1C,SEG15_2A|SEG15_2B|SEG15_2C,SEG17_3A|SEG17_3B|SEG17_3C,SEG19_4A|SEG19_4B|SEG19_4C,SEG21_5A|SEG21_5B|SEG21_5C,
								SEG23_6A|SEG23_6B|SEG23_6C,SEG10_7A,SEG8_8A,SEG6_9A,SEG4_10A};
    uint8_t  index = para0[pos-1];

    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
		Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
		Ht1621WriteSegVal(index+1, para2[pos-1]);
    }
}
//显示数字8	\A\B\C\D\E\F\G
void LcdDisplayEight(DATA_POS_t pos)
{
    const uint8_t para0[] = {12,14,16,18,20,22,8,6,4,2};
    const uint8_t para1[] = {SEG12_1E|SEG12_1F|SEG12_1G,SEG14_2E|SEG14_2F|SEG14_2G,SEG16_3E|SEG16_3F|SEG16_3G,SEG18_4E|SEG18_4F|SEG18_4G,SEG20_5E|SEG20_5F|SEG20_5G,
								SEG22_6E|SEG22_6F|SEG22_6G,SEG9_7B|SEG9_7C|SEG9_7G,SEG7_8B|SEG7_8C|SEG7_8G,SEG5_9B|SEG5_9C|SEG5_9G,SEG3_10B|SEG3_10C|SEG3_10G};
    const uint8_t para2[] = {SEG13_1A|SEG13_1B|SEG13_1C|SEG13_1D,SEG15_2A|SEG15_2B|SEG15_2C|SEG15_2D,SEG17_3A|SEG17_3B|SEG17_3C|SEG17_3D,SEG19_4A|SEG19_4B|SEG19_4C|SEG19_4D,SEG21_5A|SEG21_5B|SEG21_5C|SEG21_5D,
								SEG23_6A|SEG23_6B|SEG23_6C|SEG23_6D,SEG10_7A|SEG10_7D|SEG10_7E|SEG10_7F,SEG8_8A|SEG8_8D|SEG8_8E|SEG8_8F,SEG6_9A|SEG6_9D|SEG6_9E|SEG6_9F,SEG4_10A|SEG4_10D|SEG4_10E|SEG4_10F};
    uint8_t  index = para0[pos-1];

    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
		Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
		Ht1621WriteSegVal(index+1, para2[pos-1]);
    }
}
//显示数字9 \A\B\C\D\F\G
void LcdDisplayNine(DATA_POS_t pos)
{
    const uint8_t para0[] = {12,14,16,18,20,22,8,6,4,2};
    const uint8_t para1[] = {SEG12_1F|SEG12_1G,SEG14_2F|SEG14_2G,SEG16_3G|SEG16_3F,SEG18_4G|SEG18_4F,SEG20_5G|SEG20_5F,SEG22_6G|SEG22_6F,
								SEG9_7B|SEG9_7C|SEG9_7G,SEG9_7B|SEG9_7C|SEG9_7G,SEG7_8B|SEG7_8C|SEG7_8G,SEG5_9B|SEG5_9C|SEG5_9G,SEG3_10B|SEG3_10C|SEG3_10G};
    const uint8_t para2[] = {SEG13_1A|SEG13_1B|SEG13_1C|SEG13_1D,SEG15_2A|SEG15_2B|SEG15_2C|SEG15_2D,SEG17_3A|SEG17_3B|SEG17_3C|SEG17_3D,SEG19_4A|SEG19_4B|SEG19_4C|SEG19_4D,SEG21_5A|SEG21_5B|SEG21_5C|SEG21_5D,
								SEG23_6A|SEG23_6B|SEG23_6C|SEG23_6D,SEG10_7A|SEG10_7D|SEG10_7F,SEG8_8A|SEG8_8D|SEG8_8F,SEG6_9A|SEG6_9D|SEG6_9F,SEG4_10A|SEG4_10D|SEG4_10F};
    uint8_t  index = para0[pos-1];

    LcdClrData(pos);
    if ((FIRST <= pos) && (pos <= TEN)) {
        Ht1621WriteSegVal(index, Ht1621ReadSegVal(index) | para1[pos-1]);
		Ht1621WriteSegVal(index+1, para2[pos-1]);
    }
}

////显示\清除符号小数点.
void LcdDisplayPoint( DATA_POS_t pos, LCD_Display_TypeDef displayFlg)
{
	switch(pos){
		case FIRST:
			LcdDisplay(8, SEG9_DP1, displayFlg);
			break;

		case SECOND:
			LcdDisplay(6, SEG7_DP2, displayFlg);
			break;

		case THIRD:
			LcdDisplay(4, SEG5_DP3, displayFlg);
			break;
		default:
			break;
	}
}

//显示\清除符号冒号:
void LcdDisplayCol(DATA_POS_t pos, LCD_Display_TypeDef displayFlg)
{
	switch(pos){
		case 1:
			LcdDisplay(16, SEG16_COL1, displayFlg);
			break;
		case 2:
			LcdDisplay(20, SEG20_COL2, displayFlg);
			break;
		default:
			break;
	}
}

void LcdEnterInitStu(void)
{
	//LcdTurnOnLed();
	//SwitchToUi_PowerOn();			
}

void LcdDisplayAllEdge(void)
{
	LcdDisplayEdge(LCD_DISPLAY);
	LcdDisplayTab1Edge(LCD_DISPLAY);
	LcdDisplayTab2Edge(LCD_DISPLAY);
	LcdDisplayTab3Edge(LCD_DISPLAY);
}

void LcdDisplayAll(void)
{
	LcdTurnOnLed();
	LcdAllOff();
	rt_thread_mdelay(1000);
	LcdDisplayBackStageConnect(LCD_DISPLAY);
	rt_thread_mdelay(200);
	LcdDisplaySingnal(LCD_DISPLAY); //信号图标
	rt_thread_mdelay(200);
	LcdDisplayNoSingnal(LCD_DISPLAY); //无信号图标
	rt_thread_mdelay(200);
	LcdDisplayBlutooth(LCD_DISPLAY); //蓝牙图标
	rt_thread_mdelay(200);
	LcdDisplayChgMethod(LCD_DISPLAY); //扫码或刷卡开启充电
	rt_thread_mdelay(200);
	LcdDisplaySuccess(LCD_DISPLAY); //成功
	rt_thread_mdelay(200);
	LcdDisplayFailure(LCD_DISPLAY); //失败
	rt_thread_mdelay(200);
	LcdDisplayProgressBar1(LCD_DISPLAY); //进度条1
	rt_thread_mdelay(200);
	LcdDisplayProgressBar2(LCD_DISPLAY); //进度条2
	rt_thread_mdelay(200);
	LcdDisplayProgressBar3(LCD_DISPLAY); //进度条3
	rt_thread_mdelay(200);
	LcdDisplayProgressBar4(LCD_DISPLAY); //进度条边框-充电中
	rt_thread_mdelay(200);
	LcdDisplayYuan(LCD_DISPLAY); //元
	rt_thread_mdelay(200);
	LcdDisplayChargeing(LCD_DISPLAY); //预充
	rt_thread_mdelay(200);
	LcdDisplaySocketIdle(LCD_DISPLAY); //已充，函数名还是沿用猛犸的，可能不太对
	rt_thread_mdelay(200);
	LcdDisplayInvalid(LCD_DISPLAY); //无效
	rt_thread_mdelay(200);
	LcdDisplayKW(LCD_DISPLAY); //kw, s17
	rt_thread_mdelay(200);
	LcdDisplayA(LCD_DISPLAY); //A, s20
	rt_thread_mdelay(200);
	LcdDisplayV(LCD_DISPLAY); //A, s20
	rt_thread_mdelay(200);
	LcdDisplaySocketFault(LCD_DISPLAY); //故障
	rt_thread_mdelay(200);
	LcdDisplayCardBalance(LCD_DISPLAY); //卡片余额
	rt_thread_mdelay(200);
	LcdDisplaySocketNum(LCD_DISPLAY ); //实时信息
	rt_thread_mdelay(200);
	LcdDisplayChargeingMoney(LCD_DISPLAY ); //充电金额
	rt_thread_mdelay(200);
	LcdDisplayEdge(LCD_DISPLAY); //第三行大边框 [ ]
	rt_thread_mdelay(200);
	LcdDisplayTab1Edge(LCD_DISPLAY); //卡片余额边框
	rt_thread_mdelay(200);
	LcdDisplayTab2Edge(LCD_DISPLAY); //实时信息边框
	rt_thread_mdelay(200);
	LcdDisplayTab3Edge(LCD_DISPLAY);//充电金额边框
	rt_thread_mdelay(200);
	LcdDisplayH(LCD_DISPLAY); //h
	rt_thread_mdelay(200);
	LcdDisplayRemainingTime(LCD_DISPLAY); //充电时长
	rt_thread_mdelay(200);
	LcdDisplayClockDial(LCD_DISPLAY); //表
	rt_thread_mdelay(200);
    #if 1
    for(int i=1; i<11; i++){
      LcdDisplayZero((DATA_POS_t)i);
      rt_thread_mdelay(100);
   }
    for(int i=1; i<11; i++){
      LcdDisplayOne((DATA_POS_t)i);
      rt_thread_mdelay(100);
     }
    for(int i=1; i<11; i++){
      LcdDisplayTwo((DATA_POS_t)i);
      rt_thread_mdelay(100);
    }

    for(int i=1; i<11; i++){
      LcdDisplayThree((DATA_POS_t)i);
      rt_thread_mdelay(100);
    }

    for(int i=1; i<11; i++){
      LcdDisplayFour((DATA_POS_t)i);
      rt_thread_mdelay(100);
    }

    for(int i=1; i<11; i++){
      LcdDisplayFive((DATA_POS_t)i);
      rt_thread_mdelay(100);
    }

    for(int i=1; i<11; i++){
      LcdDisplaySix((DATA_POS_t)i);
      rt_thread_mdelay(100);
    }

    for(int i=1; i<11; i++){
      LcdDisplaySeven((DATA_POS_t)i);
      rt_thread_mdelay(100);
    }

    for(int i=1; i<11; i++){
      LcdDisplayEight((DATA_POS_t)i);
      rt_thread_mdelay(100);
    }

	for(int i=1; i<11; i++){
      LcdDisplayNine((DATA_POS_t)i);
      rt_thread_mdelay(100);
    }
    #endif
    for(int i=1; i<6; i++){
      LcdDisplayEight((DATA_POS_t)i);
    }
    for(int i=7; i<11; i++){
      LcdDisplayZero((DATA_POS_t)i);
    }
    for(int i=1; i<4; i++){
      LcdDisplayPoint((DATA_POS_t)i, LCD_DISPLAY);
    }
    for(int i=1; i<3; i++){
      LcdDisplayCol((DATA_POS_t)i, LCD_DISPLAY);
    }
}

/**
***Ht1621芯片初始化
***
**/
void Ht1621Init(void)
{
    rt_kprintf("Ht1621Init\n");

	rt_pin_mode(HT1621_CS, PIN_MODE_OUTPUT);//gpio_init(LCD_CS_GPIO, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, LCD_CS_PIN);
	rt_pin_mode(HT1621_RD, PIN_MODE_OUTPUT);//gpio_init(LCD_RDN_GPIO, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, LCD_RDN_PIN);
	rt_pin_mode(HT1621_WR, PIN_MODE_OUTPUT);//gpio_init(LCD_WRN_GPIO, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, LCD_WRN_PIN);
	//gpio_init(LCD_LIGHT_GPIO, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, LCD_LIGHT_PIN);
	rt_pin_mode(HT1621_DATA, PIN_MODE_OUTPUT);//gpio_init(LCD_DATA_GPIO, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, LCD_DATA_PIN);
	
	Ht1621_WR_1();
	Ht1621_CS_1();
	Ht1621_RD_1();
	Ht1621_DATA_1();
	
	rt_thread_mdelay(1000);//vTaskDelay(1000);

	Ht1621WrCmd(BIAS);
	Ht1621WrCmd(SYSDIS);
	//Ht1621WrCmd(XTAL);			//使用外部晶振 32.768k
	Ht1621WrCmd(RC256);			//使用内部晶振 32.768k
	Ht1621WrCmd(WDTDIS1);
	Ht1621WrCmd(SYSEN);
	Ht1621WrCmd(LCDON);
	//Ht1621WrCmd(0x12);
	//Ht1621WrCmd(0x10);

}

void LcdInit(void)
{
	Ht1621Init();
	LcdAllOff();
	LcdTurnOnLed();
	LcdAllOn();
    rt_kprintf("init ok.\n");
}

uint32_t ProgressloopCnt = 0;
void UiProgressLoop(void)
{
	ProgressloopCnt++;
	if (ProgressloopCnt == 1) {
		LcdDisplayProgressBar1(LCD_DISPLAY);
		LcdDisplayProgressBar2(LCD_CLEAR);
		LcdDisplayProgressBar3(LCD_CLEAR);
		LcdDisplayProgressBar4(LCD_DISPLAY);
	} else if (ProgressloopCnt == 2) {
		LcdDisplayProgressBar1(LCD_DISPLAY);
		LcdDisplayProgressBar2(LCD_DISPLAY);
		LcdDisplayProgressBar3(LCD_CLEAR);
		LcdDisplayProgressBar4(LCD_DISPLAY);
	} else if (ProgressloopCnt == 3) {
		LcdDisplayProgressBar1(LCD_DISPLAY);
		LcdDisplayProgressBar2(LCD_DISPLAY);
		LcdDisplayProgressBar3(LCD_DISPLAY);
		LcdDisplayProgressBar4(LCD_DISPLAY);
	} else if (ProgressloopCnt == 4) {
		LcdDisplayProgressBar1(LCD_DISPLAY);
		LcdDisplayProgressBar2(LCD_DISPLAY);
		LcdDisplayProgressBar3(LCD_DISPLAY);
		LcdDisplayProgressBar4(LCD_DISPLAY);
	}

	if (ProgressloopCnt == 4) {
		ProgressloopCnt = 0;
	}
}

void UiDisplayNomalInfo(void)
{
	LcdAllOff();
	 if (1) {
		LcdDisplayBackStageConnect(LCD_DISPLAY);
    }
	if (1) {
		LcdDisplaySingnal(LCD_DISPLAY);
	} else {
		LcdDisplayNoSingnal(LCD_DISPLAY);
	}
	LcdDisplayClockDial(LCD_DISPLAY);
}

//上电开机页面
void SwitchToUi_PowerOn(void)
{
	LcdAllOff();
	LcdDisplayNoSingnal(LCD_DISPLAY);
	LcdDisplayChgMethod(LCD_DISPLAY);
	ProgressloopCnt = 0;
	//UpdateNewUiState(UI_POWERON);
}
//待机页面
void SwitchToUi_Standby(void)
{
	if (0) {
		UiDisplayNomalInfo();
	} else {
		LcdAllOff();
		LcdDisplayNoSingnal(LCD_DISPLAY);
		LcdDisplayClockDial(LCD_DISPLAY);
	}
	LcdDisplayChgMethod(LCD_DISPLAY);
	//UpdateNewUiState(UI_STANDBY);
}

//lcd相对位置显示数字
void UiDisplay_PosData(uint8_t pos, uint8_t data)
{
    void (*afun[])(DATA_POS_t) = {LcdDisplayZero,LcdDisplayOne,LcdDisplayTwo,LcdDisplayThree,LcdDisplayFour,LcdDisplayFive,LcdDisplaySix,LcdDisplaySeven,LcdDisplayEight,LcdDisplayNine};

	if ((data>9) || (pos>11) || (pos<1)) {
		return;
	}
    afun[data]((DATA_POS_t)pos);
}

//////////////////////////////////// duanma end
#endif


//////////////////////////////////////////////////////
//////////////////       dianzhen start
/////////////////////////////////////////////////////
#if 0
#define Uchar unsigned char
#define Uint  unsigned int

//#define dataport  P1
#define nop  __NOP()

#define G12864_RS       14
#define G12864_SCL      15
#define G12864_SI       30
#define G12864_CS       29

Uchar   EV=41;

Uchar snow[]={0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55};
Uchar clear[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
Uchar black[]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
Uchar map[]={
 /*--  调入了一幅图像：E:\LCM\G12864B\B10-1\图片.bmp  --*/
/*--  宽度x高度=128x64  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x02,0xBA,0xBA,0xEA,0xFA,0xBB,0x83,0xFA,0xFA,0xAA,0xBA,0xBA,0x02,0x02,0x00,
0x00,0xFE,0xFE,0x32,0xFE,0xCE,0xFE,0xFE,0x42,0x42,0x42,0x42,0xFF,0xFF,0x02,0x00,
0x80,0xC0,0x60,0x30,0x18,0x0E,0xC6,0xC0,0x07,0x1F,0x38,0x60,0xC0,0xC0,0x40,0x00,
0x04,0x84,0xC4,0x64,0xF4,0xD4,0x05,0x07,0x06,0xC4,0xD4,0x34,0x66,0x46,0x04,0x00,
0x00,0xF0,0xF0,0x00,0x00,0xC0,0xE0,0x30,0x10,0x10,0x30,0x60,0x40,0x40,0x40,0x40,
0x40,0x40,0x40,0xFF,0xFF,0x44,0x44,0x46,0x46,0x64,0x60,0x40,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x12,0x12,0x12,0x1A,0x3F,0x3F,0x32,0x16,0x0F,0x1B,0x1A,0x3E,0x26,0x22,0x22,0x00,
0x00,0x3F,0x3F,0x06,0x07,0x03,0x3F,0x3F,0x08,0x08,0x08,0x08,0x1F,0x1F,0x00,0x00,
0x00,0x00,0x10,0x38,0x3C,0x17,0x13,0x10,0x12,0x16,0x1C,0x38,0x30,0x00,0x00,0x00,
0x00,0x20,0x20,0x20,0x30,0x11,0x1B,0x0E,0x0F,0x1B,0x10,0x30,0x20,0x20,0x20,0x00,
0x00,0x1F,0x1F,0x00,0x00,0x07,0x0F,0x18,0x10,0x10,0x18,0x0C,0x04,0x00,0x00,0x00,
0x00,0x00,0x00,0x3F,0x3F,0x01,0x03,0x02,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x30,0x10,0x10,0xF0,0xE0,0x00,
0x00,0xE0,0xF0,0x10,0x10,0xF0,0xE0,0x00,0x00,0x20,0x20,0xF0,0xF0,0x00,0x00,0x00,
0x00,0x00,0xC0,0xE0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,
0xF0,0xF0,0x00,0x00,0x00,0x00,0xE0,0xF0,0x10,0x10,0xF0,0xE0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x30,0x10,0x10,0xF0,0xE0,0x00,0x00,0xE0,0xF0,0x10,0x10,0xF0,
0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x1C,0x16,0x13,0x11,0x10,0x00,
0x00,0x0F,0x1F,0x10,0x10,0x1F,0x0F,0x00,0x00,0x00,0x00,0x1F,0x1F,0x00,0x00,0x00,
0x06,0x07,0x05,0x04,0x1F,0x1F,0x04,0x00,0x02,0x02,0x02,0x02,0x02,0x00,0x00,0x00,
0x1F,0x1F,0x00,0x00,0x00,0x00,0x0F,0x1F,0x10,0x10,0x1F,0x0F,0x00,0x02,0x02,0x02,
0x02,0x02,0x00,0x18,0x1C,0x16,0x13,0x11,0x10,0x00,0x00,0x0F,0x1F,0x10,0x10,0x1F,
0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x20,0xF0,0xF0,0x00,0x00,0x00,0x00,0x20,0x20,0xF0,0xF0,0x00,0x00,0x00,
0x00,0x80,0x80,0x00,0x00,0x00,0xC0,0xE0,0xF0,0xF0,0x00,0x00,0x00,0x10,0x10,0x10,
0xD0,0xF0,0x30,0x00,0x00,0x80,0x80,0x00,0x00,0x00,0xC0,0xE0,0xF0,0xF0,0x00,0x00,
0x00,0x10,0x10,0x10,0xD0,0xF0,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1F,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x00,0x00,0x00,
0x00,0x10,0x10,0x00,0x06,0x07,0x05,0x04,0x1F,0x1F,0x04,0x00,0x00,0x00,0x1C,0x1F,
0x03,0x00,0x00,0x00,0x00,0x10,0x10,0x00,0x06,0x07,0x05,0x04,0x1F,0x1F,0x04,0x00,
0x00,0x00,0x1C,0x1F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x98,0xCC,0xE7,0x3B,0xB8,0xA4,0xA4,
0xBF,0xBF,0xE4,0xE4,0xA4,0xA4,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,
0x20,0x20,0x20,0x30,0x30,0x20,0x00,0x00,0x40,0x60,0x30,0xFC,0xFF,0x4B,0x48,0xC8,
0xF8,0x7F,0x4F,0x48,0x48,0x48,0x40,0x00,0x20,0x20,0x21,0xE7,0xE6,0x00,0xC4,0xC4,
0x44,0x44,0x44,0x44,0x7E,0x7E,0x04,0x00,0x20,0x20,0xA2,0xAA,0xAA,0x2A,0x2A,0xEA,
0xEA,0x2A,0x3F,0xBF,0xA2,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x30,0x10,0x10,0xF0,0xE0,0x00,
0x00,0x00,0xC0,0xE0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x3F,0x3F,0x00,0x00,0x02,0x06,
0x14,0x30,0x3F,0x1F,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x1F,0x1F,
0x10,0x10,0x10,0x10,0x18,0x18,0x10,0x00,0x00,0x00,0x00,0x3F,0x3F,0x00,0x00,0x09,
0x09,0x19,0x39,0x2D,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x0C,0x1F,0x3F,
0x20,0x20,0x20,0x20,0x20,0x3C,0x3C,0x00,0x10,0x10,0x18,0x08,0x0D,0x17,0x32,0x3F,
0x1F,0x03,0x07,0x0D,0x18,0x18,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x18,0x11,0x11,0x1F,0x0E,0x00,
0x06,0x07,0x05,0x04,0x1F,0x1F,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

Uchar map1[]={
/*--  调入了一幅图像：E:\测试程序图片\12864\12864-1.bmp  --*/
/*--  宽度x高度=128x64  --*/
0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xC1,0x41,0x21,0x21,
0x01,0x81,0xE1,0x81,0x81,0x81,0x01,0x41,0xC1,0x41,0x01,0xC1,0x81,0x81,0xE1,0x81,
0x81,0xC1,0x01,0x01,0x21,0xC1,0x01,0x01,0x01,0xE1,0x01,0x01,0x01,0x01,0x01,0x21,
0x41,0x01,0xE1,0x21,0x21,0xE1,0x01,0x81,0x01,0xE1,0x01,0x21,0xC1,0x01,0x81,0x81,
0x81,0x81,0x81,0xE1,0xA1,0xC1,0x01,0x01,0x81,0x81,0x81,0xE1,0x81,0x81,0x81,0xC1,
0x81,0x01,0x01,0x01,0xE1,0x21,0x21,0x21,0xE1,0x21,0x21,0x21,0xE1,0x01,0x01,0x41,
0x41,0xE1,0x21,0x01,0xE1,0x21,0x21,0x21,0xE1,0x01,0x01,0x01,0xC1,0x41,0x41,0x41,
0x61,0x41,0x41,0x41,0x41,0x41,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x3F,0x02,0xFE,0x82,
0x42,0x21,0x1E,0x20,0x42,0x81,0x00,0x22,0x3F,0x12,0x10,0xFA,0x0A,0x7E,0x0A,0x7A,
0x8A,0xFA,0x00,0xC2,0x3E,0x40,0xA1,0x91,0x89,0x87,0x89,0x91,0xB1,0x81,0x00,0x11,
0xFE,0x80,0x9F,0x40,0x3F,0x5F,0x80,0x3F,0x80,0xFF,0x00,0x02,0xFE,0x40,0x20,0x44,
0x7C,0x24,0x24,0x3F,0x40,0xE0,0x00,0x02,0x02,0x02,0x2E,0x2B,0x4A,0x4A,0xAA,0x1A,
0x02,0x02,0x00,0xC0,0x3F,0x09,0x09,0x09,0xFF,0x09,0x89,0x89,0xFF,0x00,0x00,0x31,
0x0D,0xFF,0x09,0x84,0x95,0x95,0xFD,0x95,0x95,0x84,0x00,0xC0,0x3F,0x08,0x09,0x89,
0x8B,0xFD,0x0B,0x09,0x18,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xF8,0x40,0x40,0xF8,
0x08,0x08,0xF8,0x48,0xE8,0x18,0x00,0x08,0x38,0xC0,0x38,0x08,0x00,0x00,0x10,0xF8,
0x00,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x00,0xE0,0x10,0x08,0x88,0x98,0x80,0x00,
0x10,0xF8,0x00,0x00,0x00,0x30,0x08,0x88,0x48,0x30,0x00,0xB0,0x48,0x48,0x48,0xB0,
0x00,0xF0,0x48,0x48,0x58,0x80,0x00,0x80,0x60,0x10,0xF8,0x00,0x00,0x08,0xF8,0x48,
0x48,0xB0,0x00,0x00,0x10,0xF8,0x00,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
0xC0,0x38,0xE0,0x00,0x00,0xF0,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x07,0xC0,0x40,0x47,
0x64,0x44,0x47,0x44,0xC4,0x06,0x00,0x04,0xE7,0x20,0x27,0x24,0xE0,0x20,0x24,0x27,
0xE4,0x00,0x00,0xC0,0x40,0x40,0xC0,0x80,0x80,0x81,0x82,0xE4,0x84,0x83,0x00,0x80,
0x24,0x47,0x04,0x20,0x20,0x26,0x25,0x24,0xE4,0x04,0x00,0x03,0x04,0x04,0x04,0x03,
0x00,0x03,0x04,0x84,0x04,0x03,0x00,0x00,0x81,0x81,0x87,0x05,0x00,0x04,0x07,0x04,
0x04,0x03,0x00,0x00,0x84,0x87,0x84,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x04,
0x07,0x01,0x01,0x07,0x04,0x03,0x84,0x84,0x84,0x03,0x00,0x00,0x80,0x80,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x1F,0xFA,0x8A,
0x8A,0x8A,0x8A,0x8A,0xFB,0x00,0x00,0xC0,0x3F,0x09,0x09,0x09,0xFF,0x09,0x89,0x89,
0xFF,0x00,0x00,0x7F,0x24,0x24,0x7F,0x00,0x02,0x8C,0x80,0xFF,0x00,0x00,0x00,0xFF,
0x00,0x00,0x3F,0x25,0x25,0x25,0x3F,0x80,0xFF,0x00,0x00,0x00,0x00,0x42,0x00,0x00,
0x00,0x00,0x41,0x7F,0x40,0x00,0x00,0x21,0x40,0x44,0x44,0x3B,0x00,0x00,0x40,0x00,
0x00,0x00,0x00,0x3F,0x40,0x40,0x40,0x3F,0x00,0x07,0x68,0x48,0x48,0x3F,0x00,0x00,
0x40,0x00,0x00,0x00,0x00,0x63,0x50,0x48,0x44,0x43,0x00,0x21,0x40,0x44,0x44,0x3B,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x22,0xE4,
0x40,0x20,0xDE,0x42,0x42,0x5E,0xD0,0x10,0x00,0x20,0xE2,0x04,0x00,0x20,0x20,0x20,
0xFE,0x20,0x20,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x64,0xA4,0xA4,0xAE,0xE4,
0xA4,0xA4,0xAE,0xA4,0x24,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x7C,0x14,
0x54,0x74,0x84,0x5E,0x24,0x56,0x84,0xE4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,
0x0A,0x08,0x08,0x05,0x02,0x05,0x08,0x08,0x00,0x00,0x0F,0x04,0x02,0x00,0x00,0x00,
0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x08,0x08,0x08,0x04,0x03,
0x08,0x08,0x08,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x0F,0x09,
0x09,0x0F,0x09,0x0F,0x09,0x0F,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF
};
Uchar map5[]={
/*--  调入了一幅图像：E:\测试程序图片\12864\12864-1.bmp  --*/
/*--  宽度x高度=128x64  --*/
0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x41,0x41,0x41,0x41,0xC1,0xC1,0x81,0xF1,0xF1,
  0x81,0x81,0x81,0x81,0x01,0x01,0x01,0x11,0x31,0x21,0xE1,0xE1,0x21,0x31,0xF1,0xE1,
  0x21,0xE1,0xE1,0x01,0x01,0x01,0x01,0xC1,0xF1,0x71,0x41,0x41,0xF1,0xF1,0x41,0x61,
  0x61,0x41,0x01,0x01,0x01,0x01,0xF1,0xF1,0x11,0x11,0xF1,0xF1,0x11,0x11,0xF1,0xF1,
  0x01,0x01,0x01,0x41,0xC1,0xC1,0x41,0xC1,0xC1,0x41,0x01,0x41,0xC1,0xC1,0x41,0x41,
  0xC1,0x81,0x01,0x41,0xC1,0xC1,0x41,0xC1,0x81,0x01,0x01,0x41,0x41,0x41,0xC1,0xC1,
  0x51,0x71,0x61,0xC1,0xC1,0x41,0x41,0x41,0x01,0x01,0x01,0x01,0x01,0xF1,0xF1,0x11,
  0x11,0x11,0xF1,0xF1,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x73,0x3E,0x1F,0xB3,0xE2,0x63,0x31,0x1E,
  0x3E,0x71,0xC1,0x80,0x00,0x00,0x81,0xC1,0x7F,0x7F,0xDF,0x9F,0x8C,0x84,0xBF,0xBF,
  0x98,0x9F,0x8F,0x00,0x00,0x02,0x03,0xFF,0xFF,0x8F,0xDF,0x75,0x7F,0x5F,0xC5,0x8F,
  0x8F,0x80,0x00,0x00,0x80,0xC0,0x7F,0x3F,0x09,0x09,0xFF,0xFF,0x09,0x89,0xFF,0xFF,
  0x00,0x00,0x00,0x40,0x71,0x7F,0x4E,0x7F,0x71,0x40,0x00,0x40,0x7F,0x7F,0x46,0x1E,
  0x7B,0x61,0x40,0x40,0x7F,0x7F,0x40,0x60,0x3F,0x1F,0x00,0xC0,0xFE,0x3E,0x02,0x03,
  0x03,0x02,0x03,0x03,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0xFC,0xFC,0x45,0xFD,0xFD,
  0x01,0xFD,0xFD,0x45,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
  0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x02,0x02,0x07,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0xFF,0xFF,0xFF,0x61,0x21,0x61,0xE1,0xE1,0xC1,0x81,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x70,0x70,0x70,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0xFF,0x61,0x21,0x61,0xE1,0xE1,0xC1,0x81,0x00,0x00,0x00,0xFE,0xFF,0xFF,
  0xC7,0x01,0x01,0x01,0x81,0xCF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x35,
  0x24,0x3F,0x1B,0x00,0x1F,0x3F,0x24,0x24,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xF0,0xF1,0xF1,0x80,0x00,0x80,0x80,0xF1,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,
  0xF1,0xF1,0x80,0x00,0x80,0x80,0xF1,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0xE1,0xE3,
  0xE3,0x83,0x82,0x83,0xE3,0xFF,0xFF,0x3F,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x50,0xF0,0xFC,0xFC,0xFC,0x5C,0x50,0x00,0xF8,0xFC,0x04,0xFC,0xF8,0x00,0x00,0xF8,
  0xFC,0x04,0xFC,0xF8,0x00,0x00,0x08,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,
  0x80,0x80,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0x80,0x80,0x80,
  0x80,0xC1,0xC1,0x01,0x01,0x00,0x00,0x00,0xC0,0xC1,0xC1,0xC1,0x80,0x80,0x80,0x80,
  0x81,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x62,0x73,0x59,0x4F,0x46,0x00,0x00,
  0x3E,0x7F,0x41,0x7F,0x3E,0x00,0x00,0x42,0x7F,0x7F,0x40,0x00,0x00,0x18,0x1C,0x16,
  0x7F,0x7F,0x10,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x3E,0x7F,0x41,0x7F,
  0x3E,0x00,0x3E,0x7F,0x49,0x49,0x79,0x30,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x00,
  0x00,0x42,0x7F,0x7F,0x40,0x00,0x00,0x3E,0x7F,0x49,0x49,0x79,0x30,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xB0,0xBB,0xBF,0xB4,0xFC,0xFC,
  0xB4,0xBF,0xAB,0x80,0x00,0x00,0x00,0x50,0x7F,0x3F,0xFF,0xFF,0x7D,0x3F,0x12,0xFF,
  0xFF,0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,
};
Uchar map2[]={
/*--  调入了一幅图像：E:\测试程序图片\12864\12864-2.bmp  --*/
/*--  宽度x高度=128x64  --*/
0xFF,0x03,0x03,0x05,0x05,0x09,0x09,0x11,0x11,0x21,0x21,0x41,0x41,0x81,0x81,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x81,0x81,0x41,0x41,0x21,0x21,0x11,0x11,0x09,0x09,0x05,0x05,0x03,0x03,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x01,0x02,0x02,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x01,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x01,0x02,0x02,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x40,0x80,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x80,0x40,0x40,0x20,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x01,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x01,0x02,0x02,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80,
0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x01,0x01,
0x01,0x01,0x02,0x02,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x02,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x01,0x02,0x02,0x04,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x80,
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x01,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x01,0x02,0x02,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x80,
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0xC0,0xC0,0xA0,0xA0,0x90,0x90,0x88,0x88,0x84,0x84,0x82,0x82,0x81,0x81,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x80,0x81,0x81,0x82,0x82,0x84,0x84,0x88,0x88,0x90,0x90,0xA0,0xA0,0xC0,0xC0,0xFF,
};
Uchar map3[]={
/*--  调入了一幅图像：E:\测试程序图片\12864\12864-3.bmp  --*/
/*--  宽度x高度=128x64  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xF0,0xF0,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xF0,0x30,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xF0,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xF0,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0xF0,0xF0,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,
0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x3F,
0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0xFF,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0xFF,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0xFF,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xFF,0x30,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xFF,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xFF,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF0,0xF8,0xFE,0xFF,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x1E,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x07,0x07,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x07,0x06,0x06,0x06,0x06,
0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x07,0x06,0x06,0x06,
0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x07,0x06,
0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
0x06,0x06,0x06,0x06,0x06,0x07,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
Uchar map4[]={
/*--  调入了一幅图像：E:\测试程序图片\12864\12864-1.bmp  --*/
/*--  宽度x高度=128x64  --*/
0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x60,0xC0,
  0x80,0x00,0x00,0xF0,0xF0,0x00,0x00,0x00,0xC0,0xE0,0x60,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x12,0xD2,0xD2,0x12,0x12,0x12,0x12,0x12,0x12,
  0xD2,0xD2,0x13,0x13,0x1C,0x1C,0x00,0x00,0x00,0x00,0x0F,0x0F,0x01,0x39,0x7D,0x4D,
  0x45,0x45,0x45,0xC5,0xC5,0x45,0x45,0x45,0x45,0x7D,0x39,0x19,0x1F,0x0F,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x02,0x82,0xC2,0x62,0x72,0x3F,0x0F,0x02,0x02,0x02,0x02,0x02,0x02,
  0xFF,0xFF,0x02,0x02,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x7E,0x7F,0x01,0x01,
  0x01,0x01,0x01,0xFF,0xFF,0x01,0x01,0x41,0x41,0x41,0x43,0x7F,0x3E,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,
};

Uchar map6[]={
/*--  调入了一幅图像：C:\Users\MATEBOOKD14\Desktop\HC32F460\1.bmp  --*/
/*--  宽度x高度=128x64  --*/
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0xEF,0xF7,0xF7,
0xFB,0xFB,0xFF,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFF,0xFB,0xFB,0xF7,
0xFF,0xEF,0xBF,0xFF,0xFE,0xFE,0xFF,0xFE,0xFF,0xFE,0xFF,0xFE,0xFF,0xFE,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0xFF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
0xFF,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF6,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x07,0xFF,0xFD,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFE,0xFD,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xF7,0xFB,0xFD,0xFD,0xFD,0xFF,0xFE,0xFE,0xFE,
0xFE,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFD,0xFF,0xFB,0xF7,0xEF,0x3F,0xFF,0xFF,0xFF,
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xBF,0xDF,0xFF,0xFF,
0xEF,0xFF,0xFF,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xFF,0xFF,0xEF,0xFF,0xDF,0xFF,0x7F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,
0x4A,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xF1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,
0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xF7,0xFF,0xFF,
0xEF,0xEF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFD,0xFB,0xFF,0xF7,0xF7,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF7,0xFF,0xFF,0xFB,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFD,0xFF,0xFF,0xFF,0xF7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xF7,0xFF,0xFB,0xFF,0xFD,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFB,0xFF,0xFF,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xFF,0xFF,0xFF,0xFB,0xFB,0xFF,
0xFD,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
};

Uchar qrcode64[]={
/*--  调入了一幅图像：C:\Users\MATEBOOKD14\Desktop\HC32F460\联图二维码 (2).bmp  --*/
/*--  宽度x高度=64x64  --*/
0x00,0x00,0x00,0xF8,0xF8,0xF8,0xB8,0x78,0x38,0x38,0x38,0x38,0x78,0x38,0x38,0x78,
0x38,0x38,0x38,0xF8,0xF8,0xF8,0xF8,0x00,0x00,0x00,0x00,0x10,0x38,0x38,0xF8,0xF8,
0xF8,0xF8,0x38,0xB8,0xF8,0xF8,0xF8,0x00,0x00,0xF8,0xF8,0xF8,0xF8,0x38,0x38,0x38,
0x78,0x38,0x38,0x78,0x38,0x38,0x38,0x38,0x78,0xB8,0xF8,0xF8,0xF8,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0xFF,0xFF,0x90,0x00,0xB6,0xFF,0xFF,0xFE,0xFF,0xFF,0xFE,0xFF,
0xFF,0x90,0x00,0xF6,0xFF,0xFF,0xF6,0x00,0x00,0xFF,0xFF,0xFF,0x8F,0x0F,0x0E,0x01,
0x01,0x3E,0x7F,0xFF,0xDF,0xCF,0xCF,0x00,0x00,0xF6,0xFF,0xFF,0xF6,0x00,0x90,0xFF,
0xFF,0xFE,0xFF,0xFF,0xFE,0xFF,0xFF,0xB6,0x00,0x90,0xFF,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x00,0x00,0x7F,0x7F,0x7F,0x78,0x78,0x31,0x79,0x79,0x31,0x7B,0x79,0x79,0x7B,
0x79,0x78,0x78,0x37,0x7F,0x7F,0x37,0x00,0x00,0xFF,0xFF,0xFF,0x84,0x00,0x30,0x78,
0x78,0x3E,0x0F,0x0E,0x7D,0x7B,0x79,0x00,0x00,0x37,0x7F,0x7F,0x37,0x78,0x78,0x79,
0x7B,0x79,0x79,0x7B,0x31,0x79,0x79,0x31,0x78,0x78,0x7F,0x7F,0x7F,0x00,0x00,0x00,
0x00,0x00,0x00,0xFE,0xFE,0xFE,0x24,0x00,0x8E,0xCE,0xCE,0xFE,0x7E,0x7E,0x3E,0x1E,
0x8E,0xCE,0xDE,0x8E,0xCE,0xCE,0xFE,0xF8,0xF8,0xB1,0xC3,0xF3,0x78,0x78,0x70,0x00,
0x00,0x7E,0x7E,0x7E,0xF4,0xF8,0xF0,0x78,0x78,0xFE,0xFE,0xFE,0xBE,0xCE,0xCE,0x8E,
0x1E,0x0E,0x0E,0x0E,0x7E,0x7E,0x7E,0x76,0x78,0x70,0x70,0x78,0x70,0x00,0x00,0x00,
0x00,0x00,0x00,0x7F,0x7F,0x7F,0x24,0x00,0x7D,0x7F,0x7F,0x7D,0x00,0x00,0x70,0x78,
0x71,0x73,0x7B,0x71,0x73,0x73,0x71,0x7B,0x73,0xF3,0xFB,0xF3,0xF0,0xF8,0xF0,0x00,
0x00,0x0E,0x1E,0x2E,0xFF,0xFF,0xFF,0x0E,0x1E,0x0F,0x1F,0x1F,0xFD,0xF3,0xF3,0x21,
0x00,0x30,0x70,0x70,0xFE,0xDE,0xDE,0x8E,0xDE,0xCE,0x8C,0xC0,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0xFE,0xFE,0xFE,0x1E,0x1E,0x8C,0x9E,0x9E,0x8C,0xDE,0x9E,0x9E,0xDE,
0x9E,0x1E,0x1E,0xEC,0xFE,0xFE,0xEC,0x00,0x00,0xF3,0xF3,0xF3,0xA3,0x83,0xF3,0xF0,
0xF0,0xEC,0x9E,0x9E,0x0F,0x03,0x0F,0x9E,0xDE,0x9C,0x00,0x00,0x73,0xF3,0x73,0xFF,
0xFE,0xFE,0x9E,0x9E,0xFD,0xF3,0xF3,0xF3,0xF3,0xF3,0x63,0x03,0x03,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0xFF,0xFF,0x09,0x00,0x6D,0xFF,0xFF,0x7F,0xFF,0xFF,0x7F,0xFF,
0xFF,0x09,0x00,0x6F,0xFF,0xFF,0x6F,0x00,0x00,0xFF,0xFF,0x7F,0xF3,0xF3,0xEF,0x1F,
0x1F,0x9F,0x9F,0x9F,0xFD,0xFE,0xFD,0x9F,0x9F,0xFF,0xFE,0xFE,0x7C,0xFE,0xFD,0x6B,
0x03,0x0F,0x1F,0x1F,0xFF,0xFE,0xFE,0x6F,0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1F,0x1F,0x1F,0x1D,0x1E,0x1C,0x1C,0x1C,0x1C,0x1E,0x1C,0x1C,0x1E,
0x1C,0x1C,0x1C,0x1F,0x1F,0x1F,0x1F,0x00,0x00,0x1C,0x1E,0x1D,0x1F,0x1F,0x1F,0x1C,
0x1C,0x1F,0x07,0x0B,0x1F,0x1F,0x1F,0x03,0x07,0x03,0x07,0x07,0x03,0x00,0x00,0x00,
0x00,0x08,0x1C,0x1C,0x1F,0x07,0x07,0x1F,0x1E,0x1C,0x08,0x00,0x00,0x00,0x00,0x00,
};

Uchar qrcode48[]={
/*--  调入了一幅图像：C:\Users\MATEBOOKD14\Desktop\HC32F460\联图二维码 (3).bmp  --*/
/*--  宽度x高度=48x48  --*/
0x00,0x00,0xFC,0xFC,0xFC,0x1C,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0x1C,0xBC,0xFC,
0xFC,0x00,0x80,0xC0,0xC8,0xDC,0xDC,0x7C,0x7C,0xDC,0xDC,0xFC,0xFC,0xA8,0x00,0xFC,
0xFC,0xBC,0x1C,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0x1C,0xFC,0xFC,0xFC,0x00,0x00,
0x00,0x00,0xFF,0xFF,0xFF,0xC0,0x9F,0xDF,0x9F,0xDF,0x9F,0xDF,0x9F,0xC0,0xEA,0xFF,
0xFF,0x00,0xAA,0xFF,0xFF,0x01,0x81,0xC0,0xC0,0x77,0x77,0xFF,0xDD,0x88,0x00,0xFF,
0xFF,0xEA,0xC0,0x9F,0xDF,0x9F,0xDF,0x9F,0xDF,0x9F,0xC0,0xFF,0xFF,0xFF,0x00,0x00,
0x00,0x00,0xF9,0xFD,0xF9,0x01,0x99,0xDD,0xF9,0x7D,0x79,0x1D,0x99,0xDD,0x99,0xDD,
0xFD,0xF0,0xE2,0x87,0xA7,0x70,0x70,0x01,0x01,0x7C,0x7C,0xF9,0xF1,0x61,0x70,0xFD,
0xFD,0xF9,0xDD,0x99,0x1D,0x19,0x1D,0x79,0x7D,0x79,0x71,0x61,0xF1,0x61,0x00,0x00,
0x00,0x00,0x9F,0xBF,0x9F,0x80,0x9F,0xBF,0x9F,0x80,0x98,0xB8,0x99,0xBB,0x99,0xBB,
0x99,0x3B,0x59,0xFB,0xF9,0xF8,0xF8,0x00,0x00,0x8E,0x8E,0xFF,0xFF,0xDE,0x8E,0x87,
0x0F,0xFF,0xFB,0xF9,0x80,0x98,0xB8,0xFE,0xEE,0x66,0xEE,0x66,0xE0,0x60,0x00,0x00,
0x00,0x00,0xFF,0xFF,0xFF,0x03,0xF9,0xFB,0xF9,0xFB,0xF9,0xFB,0xF9,0x03,0x57,0xFF,
0xFF,0x00,0x54,0xFE,0xFE,0xB8,0xB8,0xFE,0xFE,0xFB,0xFB,0xF1,0xE0,0xFB,0xFB,0xF1,
0xE0,0xEE,0xEE,0x7F,0x3F,0xFF,0xFB,0xFF,0xEE,0xFE,0x3E,0x3E,0x00,0x00,0x00,0x00,
0x00,0x00,0x3F,0x3F,0x3F,0x38,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x38,0x3D,0x3F,
0x3F,0x00,0x11,0x3B,0x3F,0x3F,0x3F,0x38,0x38,0x1E,0x0E,0x3F,0x3F,0x1F,0x0E,0x0F,
0x0F,0x07,0x03,0x01,0x00,0x38,0x38,0x3F,0x0F,0x3F,0x38,0x38,0x00,0x00,0x00,0x00,
};


/////////////////////////////////////////////////////////////////////////////////////////
Uchar ye[]={
/*--  文字:  液  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x10,0x61,0x06,0xE0,0x18,0x84,0xE4,0x1C,0x84,0x65,0xBE,0x24,0xA4,0x64,0x04,0x00,
0x04,0x04,0xFF,0x00,0x01,0x00,0xFF,0x41,0x21,0x12,0x0C,0x1B,0x61,0xC0,0x40,0x00
};
Uchar jing[]={
/*--  文字:  晶  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x00,0x00,0x00,0x7E,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x7E,0x00,0x00,0x00,0x00,
0x00,0x7F,0x25,0x25,0x25,0x25,0x7F,0x00,0x00,0x7F,0x25,0x25,0x25,0x25,0x7F,0x00
};
Uchar xian[]={
/*--  文字:  显  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x00,0x00,0x3E,0x2A,0xEA,0x2A,0x2A,0x2A,0xEA,0x2A,0x3E,0x00,0x00,0x00,0x00,
0x20,0x21,0x22,0x2C,0x20,0x3F,0x20,0x20,0x20,0x3F,0x28,0x24,0x23,0x20,0x20,0x00
};
Uchar shi[]={
/*--  文字:  示  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x20,0x20,0x22,0x22,0x22,0x22,0xE2,0x22,0x22,0x22,0x22,0x22,0x20,0x20,0x00,
0x10,0x08,0x04,0x03,0x00,0x40,0x80,0x7F,0x00,0x00,0x01,0x02,0x0C,0x18,0x00,0x00
};
Uchar mo[]={
/*--  文字:  模  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x10,0xD0,0xFF,0x50,0x90,0x04,0xF4,0x54,0x5F,0x54,0x54,0x5F,0xF4,0x04,0x00,0x00,
0x03,0x00,0xFF,0x00,0x00,0x84,0x85,0x45,0x35,0x0F,0x15,0x25,0x65,0xC4,0x44,0x00
};
Uchar zu[]={
/*--  文字:  组  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x20,0x38,0xA7,0x62,0x18,0x00,0xFE,0x22,0x22,0x22,0x22,0xFE,0x00,0x00,0x00,
0x00,0x22,0x23,0x22,0x12,0x12,0x20,0x3F,0x22,0x22,0x22,0x22,0x3F,0x20,0x20,0x00
};
Uchar yan[]={
/*--  文字:  研  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x02,0xC2,0xF2,0x4E,0xC2,0x02,0x40,0x42,0xFE,0x42,0x42,0x42,0xFE,0x42,0x42,0x00,
0x01,0x00,0x3F,0x10,0x9F,0x40,0x20,0x18,0x07,0x00,0x00,0x00,0xFF,0x00,0x00,0x00
};
Uchar fa[]={
/*--  文字:  发  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x10,0x3E,0x10,0x10,0xF0,0x9F,0x90,0x90,0x92,0x94,0x1C,0x10,0x10,0x10,0x00,
0x40,0x20,0x10,0x88,0x87,0x41,0x46,0x28,0x10,0x28,0x27,0x40,0xC0,0x40,0x00,0x00
};
///////////////////////////////////////////////////////////////////////////////////////
Uchar sheng[]={
/*--  文字:  生  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x80,0x60,0x1E,0x10,0x10,0x10,0x10,0xFF,0x12,0x10,0x10,0x98,0x10,0x00,0x00,
0x01,0x40,0x40,0x41,0x41,0x41,0x41,0x41,0x7F,0x41,0x41,0x41,0x41,0x61,0x40,0x00
};
Uchar chan[]={
/*--  文字:  产  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x04,0xE4,0x44,0x4C,0x74,0x54,0x45,0x46,0x64,0x54,0x4C,0x44,0x64,0x44,0x00,
0x40,0x30,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
Uchar xiao[]={

/*--  文字:  销  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x40,0x30,0x2C,0xE7,0x24,0x24,0x04,0xF2,0x94,0x98,0x9F,0x90,0x98,0xF6,0x00,0x00,
0x01,0x01,0x01,0xFF,0x41,0x21,0x00,0xFF,0x04,0x04,0x04,0x44,0x84,0x7F,0x00,0x00
};
Uchar shou[]={
/*--  文字:  售  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x40,0x20,0x10,0xFC,0x57,0x54,0x54,0x55,0xFE,0x54,0x54,0x54,0x54,0x04,0x00,0x00,
0x00,0x00,0x00,0xFD,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0xFD,0x01,0x00,0x00
};
Uchar fu[]={
/*--  文字:  服  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x00,0xFF,0x91,0x91,0xFF,0x00,0x00,0xFF,0xC1,0x41,0x49,0x51,0xCF,0x00,0x00,
0x40,0x30,0x0F,0x20,0x40,0x3F,0x00,0x00,0x7F,0x21,0x16,0x08,0x36,0x61,0x20,0x00
};
Uchar wu[]={
/*--  文字:  务  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x20,0x10,0x10,0x88,0x84,0x4F,0x52,0xA2,0x22,0x52,0x4A,0x86,0x80,0x80,0x80,0x00,
0x80,0x81,0x41,0x42,0x22,0x12,0x0E,0x03,0x02,0x42,0x82,0x7E,0x00,0x01,0x00,0x00
};
Uchar yi[]={
/*--  文字:  一  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xC0,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
Uchar ti[]={
/*--  文字:  体  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x40,0x20,0xF8,0x17,0x02,0x10,0x10,0x90,0x70,0xFF,0xD0,0x10,0x10,0x10,0x00,0x00,
0x00,0x00,0x7F,0x00,0x08,0x04,0x0A,0x09,0x08,0x7F,0x08,0x09,0x06,0x0C,0x04,0x00
};
///////////////////////////////////////////////////////////////////////////////////////
Uchar xian2[]={
/*--  文字:  先  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x80,0xE0,0x9E,0x88,0x88,0x88,0xFF,0x88,0x88,0x88,0x88,0x88,0x80,0x00,0x00,
0x00,0x80,0x40,0x20,0x18,0x07,0x00,0x00,0x00,0x3F,0x40,0x40,0x40,0x40,0x70,0x00
};
Uchar jin[]={
/*--  文字:  进  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x80,0x82,0x9C,0x88,0x00,0x88,0x88,0xFF,0x88,0x88,0x88,0xFF,0x88,0x88,0x80,0x00,
0x00,0x40,0x20,0x1F,0x20,0x50,0x4C,0x43,0x40,0x40,0x40,0x5F,0x40,0x40,0x40,0x00
};
Uchar wan[]={
/*--  文字:  完  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x90,0x8C,0xA4,0xA4,0xA4,0xA5,0xA6,0xA4,0xA4,0xA4,0xA4,0x94,0x8C,0x04,0x00,
0x00,0x80,0x40,0x20,0x18,0x07,0x00,0x00,0x00,0x3F,0x40,0x40,0x40,0x70,0x00,0x00
};
Uchar bei[]={
/*--  文字:  备  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x20,0x10,0x08,0x87,0x8A,0x52,0x22,0x22,0x52,0x8E,0x82,0x00,0x00,0x00,0x00,
0x02,0x02,0x01,0xFF,0x4A,0x4A,0x4A,0x7E,0x4A,0x4A,0x4A,0xFF,0x01,0x03,0x01,0x00
};
Uchar shi2[]={
/*--  文字:  实  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x10,0x0C,0x04,0x4C,0xB4,0x94,0x05,0xF6,0x04,0x04,0x04,0x14,0x0C,0x04,0x00,
0x00,0x82,0x82,0x42,0x42,0x23,0x12,0x0A,0x07,0x0A,0x12,0xE2,0x42,0x02,0x02,0x00
};
Uchar yan2[]={
/*--  文字:  验  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x02,0xFA,0x82,0x82,0xFE,0x80,0x40,0x60,0x58,0x46,0x48,0x50,0x20,0x20,0x20,0x00,
0x08,0x08,0x04,0x24,0x40,0x3F,0x22,0x2C,0x21,0x2E,0x20,0x30,0x2C,0x23,0x20,0x00
};
Uchar che[]={
/*--  文字:  设  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x40,0x41,0xCE,0x04,0x00,0x80,0x40,0xBE,0x82,0x82,0x82,0xBE,0xC0,0x40,0x40,0x00,
0x00,0x00,0x7F,0x20,0x90,0x80,0x40,0x43,0x2C,0x10,0x10,0x2C,0x43,0xC0,0x40,0x00
};
Uchar shi3[]={
/*--  文字:  施  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x08,0x08,0xF9,0x4E,0x48,0xC8,0x20,0x18,0xCF,0x0A,0xE8,0x88,0x88,0x88,0x08,0x00,
0x40,0x30,0x0F,0x20,0x40,0x3F,0x02,0x02,0x3F,0x41,0x5F,0x40,0x48,0x4F,0x70,0x00
};
Uchar shan[]={
/*--  文字:  善  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x44,0x44,0xD4,0x55,0x56,0x54,0xFC,0x54,0x56,0x55,0xD4,0x44,0x44,0x00,0x00,
0x02,0x02,0x02,0xFA,0x4B,0x4A,0x4A,0x4B,0x4A,0x4A,0x4B,0xFA,0x02,0x02,0x02,0x00
};
Uchar xi[]={
/*--  文字:  系  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x00,0x02,0x22,0xB2,0xAA,0x66,0x62,0x22,0x11,0x4D,0x81,0x01,0x01,0x00,0x00,
0x00,0x40,0x21,0x13,0x09,0x05,0x41,0x81,0x7F,0x01,0x05,0x09,0x13,0x62,0x00,0x00
};
Uchar tong[]={
/*--  文字:  统  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x20,0x30,0x2C,0xA3,0x60,0x10,0x84,0xC4,0xA4,0x9D,0x86,0x84,0xA4,0xC4,0x84,0x00,
0x20,0x22,0x23,0x12,0x12,0x92,0x40,0x30,0x0F,0x00,0x00,0x3F,0x40,0x41,0x70,0x00
};
Uchar guan[]={
/*--  文字:  管  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x08,0x64,0x23,0xA6,0xAA,0xA2,0xAA,0xB4,0xA3,0xA2,0xA6,0x2A,0x22,0x62,0x20,0x00,
0x00,0x00,0x00,0xFF,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4B,0xF8,0x00,0x00,0x00,0x00
};
Uchar li[]={
/*--  文字:  理  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x44,0x44,0xFC,0x44,0x44,0x00,0xFE,0x92,0x92,0xFE,0x92,0x92,0x92,0xFE,0x00,0x00,
0x10,0x10,0x0F,0x08,0x48,0x40,0x45,0x44,0x44,0x7F,0x44,0x44,0x44,0x45,0x40,0x00
};
Uchar ti2[]={
/*--  文字:  体  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x40,0x20,0xF8,0x17,0x02,0x10,0x10,0x90,0x70,0xFF,0xD0,0x10,0x10,0x10,0x00,0x00,
0x00,0x00,0x7F,0x00,0x08,0x04,0x0A,0x09,0x08,0x7F,0x08,0x09,0x06,0x0C,0x04,0x00
};
Uchar zhi[]={
/*--  文字:  制  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x50,0x4F,0x4A,0x48,0xFF,0x48,0x48,0x48,0x00,0xFC,0x00,0x00,0xFF,0x00,0x00,
0x00,0x00,0x3F,0x01,0x01,0xFF,0x21,0x61,0x3F,0x00,0x0F,0x40,0x80,0x7F,0x00,0x00
};

/////////////////////////////////////////////////////////////////////////////////////////
Uchar zhuang1[]={
/*--  文字:  状  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x08,0x30,0x00,0xFF,0x20,0x20,0x20,0x20,0xFF,0x20,0xE1,0x26,0x2C,0x20,0x20,0x00,
0x04,0x02,0x01,0xFF,0x40,0x20,0x18,0x07,0x00,0x00,0x03,0x0C,0x30,0x60,0x20,0x00};

Uchar tai1[]={
/*--  文字:  态  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x04,0x04,0x04,0x84,0x44,0x34,0x4F,0x94,0x24,0x44,0x84,0x84,0x04,0x00,0x00,
0x00,0x60,0x39,0x01,0x00,0x3C,0x40,0x42,0x4C,0x40,0x40,0x70,0x04,0x09,0x31,0x00};

Uchar shi1[]={
/*--  文字:  使  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x40,0x20,0xF0,0x1C,0x07,0xF2,0x94,0x94,0x94,0xFF,0x94,0x94,0x94,0xF4,0x04,0x00,
0x00,0x00,0x7F,0x00,0x40,0x41,0x22,0x14,0x0C,0x13,0x10,0x30,0x20,0x61,0x20,0x00};

Uchar yong1[]={
/*--  文字:  用  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x00,0x00,0xFE,0x22,0x22,0x22,0x22,0xFE,0x22,0x22,0x22,0x22,0xFE,0x00,0x00,
0x80,0x40,0x30,0x0F,0x02,0x02,0x02,0x02,0xFF,0x02,0x02,0x42,0x82,0x7F,0x00,0x00};

Uchar test1[]={
/*--  文字:  电  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x00,0xF8,0x88,0x88,0x88,0x88,0xFF,0x88,0x88,0x88,0x88,0xF8,0x00,0x00,0x00,
0x00,0x00,0x1F,0x08,0x08,0x08,0x08,0x7F,0x88,0x88,0x88,0x88,0x9F,0x80,0xF0,0x00};

Uchar test2[]={
/*--  文字:  价  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=16x16   --*/
0x00,0x80,0x60,0xF8,0x07,0x40,0x20,0x90,0x0C,0x03,0x0C,0x90,0x20,0x40,0x40,0x00,
0x01,0x00,0x00,0xFF,0x00,0x80,0x60,0x1F,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00};

Uchar test3[]={
/*--  文字:  2  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x70,0x08,0x08,0x08,0x08,0xF0,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00};

Uchar test4[]={
/*--  文字:  3  --*/
/*--  宋体12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x30,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x18,0x20,0x21,0x21,0x22,0x1C,0x00};

Uchar test5[]={
/*--  文字:  电  --*/
/*--  宋体8;  此字体下对应的点阵为：宽x高=11x11   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=16x11  --*/
0x00,0xFC,0xFC,0x54,0xFF,0xFF,0x55,0x7C,0x7C,0xFC,0x80,0x10,0x18,0x18,0x0F,0x07,
0x00,0x1F,0x1F,0x10,0x19,0x1D};

Uchar test6[]={
/*--  文字:  价  --*/
/*--  宋体8;  此字体下对应的点阵为：宽x高=11x11   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=16x11  --*/
0x30,0x3C,0xFF,0xFB,0xFD,0xFF,0x33,0xFF,0xFC,0x18,0x18,0x10,0x18,0x18,0x0F,0x07,
0x00,0x1F,0x1F,0x10,0x19,0x1D};

Uchar test7[]={
/*--  文字:  2  --*/
/*--  宋体8;  此字体下对应的点阵为：宽x高=6x11   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=11x11  --*/
0x8C,0xCE,0x62,0x76,0xBE,0x8C,0x33,0xFF,0xFC,0x18,0x18,0x10};

Uchar test8[]={
/*--  文字:  3  --*/
/*--  宋体8;  此字体下对应的点阵为：宽x高=6x11   --*/
/*--  宽度不是8的倍数，现调整为：宽度x高度=11x11  --*/
0x84,0x86,0x22,0x7E,0xFE,0xCC,0x33,0xFF,0xFC,0x18,0x18,0x10};

Uchar IC[]={0xe2,   //command reset
                 0xa1,  //adc select, a0-normal/a1-reverse
                 0xc0,  //common output mode select, 0-normal/1-reverse
                 0xa2,  //lcd drive voltage,a2 1/9bias, a3 1/7 bias
                 0x40,  //start line
                 0x2f,  //power controller set

                 0x25,   //V0 voltage regulator internal resistor ratio set   //对比度调节 V0的电阻率调节 范围：0x21-0x27 ，值越大，显示效果越浓（底影越浓）
                 0x81,   // electronic volume mode set 
				 30,   // 41 V0电压调节（可微调对比度)	//电压调整寄存器低位 范围：0x00-0x3f    值越大，显示效果越浓（底影越浓）//0x13 kehu
		
		//
                 //0xac, 
                 //0xa6, 
                 0xaf    //display on
                 };

//----------------------------------------------------------
void Delay(Uint times)
{
    while(times)
    {
        times--;
    }
}
//----------------------------------------------------------
void M_Delay(Uint NOs)
{
   while(NOs)
   {
       Delay(300);
       NOs--;
    }
}

void Displine(Uchar array[])
{
    Uint i,j,k;
    for(i=0;i<8;i++)
    {
        //WriteData(0x40,0);
        WriteData(0xb0|i,0);
        WriteData(0x10,0);
        WriteData(0x00,0);//  0x01
        for(j=0;j<16;j++)
        {
            for(k=0;k<8;k++)
            {
                WriteData(array[k],1);
            }
        }
    }
}

void WriteData(Uchar data1, Uchar di)  			   //6800
{
    Uint i,temp;
    rt_pin_write(G12864_CS, PIN_LOW);//CS1=0;
    if(di == 0)
        rt_pin_write(G12864_RS, PIN_LOW);//RS=di;
    else
        rt_pin_write(G12864_RS, PIN_HIGH);//RS=di;

    //temp=data1;
    for(i=0;i<8;i++)
    {
        //SCLK=0;
        temp=data1;
        if(temp&0x80)
            rt_pin_write(G12864_SI, PIN_HIGH);//SDI=temp&0x80;
        else
            rt_pin_write(G12864_SI, PIN_LOW);//SDI=temp&0x80;
        rt_pin_write(G12864_SCL, PIN_LOW);//SCLK=0;
        Delay(3);
        rt_pin_write(G12864_SCL, PIN_HIGH);//SCLK=1;
        data1<<=1;
        //data1=temp;
    }
    if(di == 0)
        rt_pin_write(G12864_RS, PIN_HIGH);//RS=~di;
    else
        rt_pin_write(G12864_RS, PIN_LOW);//RS=~di;
    rt_pin_write(G12864_CS, PIN_HIGH);//CS1=1;
}

void Init_lcd(void)
{
	rt_pin_mode(G12864_RS, PIN_MODE_OUTPUT);
	rt_pin_mode(G12864_SCL, PIN_MODE_OUTPUT);
	rt_pin_mode(G12864_SI,  PIN_MODE_OUTPUT);
	rt_pin_mode(G12864_CS, PIN_MODE_OUTPUT);

    int i;
    //rt_pin_write(G12864_RST, PIN_LOW);//res=0;
    //M_Delay(200);
    //rt_pin_write(G12864_RST, PIN_HIGH);//res=1;
    //M_Delay(300);
    for(i=0;i<10;i++)
    {
        WriteData(IC[i],0);
    }
}

void Dispgraphic(Uchar array[])
{
    Uint i,k;
    
    for(i=0;i<8;i++)
    {
        WriteData(0x40,0);	//半屏开始显示 0x60	或者屏蔽此处
    	WriteData(0xb0|i,0);
    	WriteData(0x10,0);
    	WriteData(0x00,0); //0x01
    	for(k=0;k<128;k++)
    	{
            WriteData(array[i*128+k],1);
    	}
    }
}

void DispQrcode(uint8_t page, uint8_t colum, Uchar *array)
{
    uint8_t i,k;
    
    for(i=0;i<page;i++)
    {
        WriteData(0x40,0); //设定起始行
    	WriteData(0xb0|i,0); //设定页,一页八行
    	WriteData(0x10,0); //设定列高四位
    	WriteData(0x00,0); //设定列低四位
    	for(k=0;k<colum;k++)
    	{
            //WriteData(array[i*colum+k],1);//连续写colum列数据
            WriteData(*(array+i*colum+k),1);//连续写colum列数据
    	}
    }
}

void DispQrcode64(Uchar array[])
{
    Uint i,k;
    
    for(i=0;i<8;i++)
    {
        WriteData(0x40,0); //设定起始行
    	WriteData(0xb0|i,0); //设定页,一页八行
    	WriteData(0x10,0); //设定列高四位
    	WriteData(0x00,0); //设定列低四位
    	for(k=0;k<64;k++)
    	{
            WriteData(array[i*64+k],1);//连续写64列数据
    	}
    }
}

void DispQrcode48(Uchar array[])
{
    Uint i,k;
    
    for(i=0;i<6;i++)
    {
        WriteData(0x40,0); //设定起始行
    	WriteData(0xb0|(i+1),0); //设定页,一页八行
    	WriteData(0x10,0); //设定列高四位
    	WriteData(0x00,0); //设定列低四位
    	for(k=0;k<48;k++)
    	{
            WriteData(array[i*48+k],1);//连续写64列数据
    	}
    }
}

void lcd_address(Uchar page,Uchar column)
{
	//CS1=0;
	column=column-1;  							//
	page=page-1;
	WriteData(0xb0+page,0);   				//设置页地址。每页是8行。一个画面的64行被分成8个页。我们平常所说的第1页，在LCD驱动IC里是第0页，所以在这里减去1*/
	WriteData(((column>>4)&0x0f)+0x10,0);	//设置列地址的高4位
	WriteData(column&0x0f,0);				//设置列地址的低4位
}

 /*显示16x16点阵图像、汉字、生僻字或16x16点阵的其他图标*/
void display_graphic_16x16_2(Uchar reverse,Uchar page,Uchar column,Uchar *dp)
{
	Uchar i,j;

 	rt_pin_write(G12864_CS, PIN_LOW);//CS1=0;
	for(j=0;j<2;j++)
	{
		lcd_address(page+j,column);
		for (i=0;i<16;i++)
		{	
			if(reverse==1)
				WriteData(*dp,1);		/*写数据到LCD,每写完一个8位的数据后列地址自动加1*/
			else
				WriteData(~*dp,1);	/*写数据到LCD,每写完一个8位的数据后列地址自动加1*/
			dp++;
		}
	}
	rt_pin_write(G12864_CS, PIN_HIGH);//CS1=1;
}

/*显示16x16点阵图像、汉字、生僻字或16x16点阵的其他图标*/
void display_graphic_8x16_1(Uchar reverse,Uchar page,Uchar column,Uchar *dp)
{
	Uchar i,j;

 	rt_pin_write(G12864_CS, PIN_LOW);//CS1=0;
	for(j=0;j<2;j++)
	{
		lcd_address(page+j,column);
		for (i=0;i<8;i++)
		{
			if(reverse==1)
				WriteData(*dp,1);		/*写数据到LCD,每写完一个8位的数据后列地址自动加1*/
			else
				WriteData(~*dp,1);	/*写数据到LCD,每写完一个8位的数据后列地址自动加1*/
			dp++;
		}
	}
	rt_pin_write(G12864_CS, PIN_HIGH);//CS1=1;
}

/*显示16x16点阵图像、汉字、生僻字或16x16点阵的其他图标*/
void display_graphic_11x16_1(Uchar reverse,Uchar page,Uchar column,Uchar *dp)
{
	Uchar i,j;

 	rt_pin_write(G12864_CS, PIN_LOW);//CS1=0;
	for(j=0;j<2;j++)
	{
		lcd_address(page+j,column);
		for (i=0;i<11;i++)
		{
			if(reverse==1)
				WriteData(*dp,1);		/*写数据到LCD,每写完一个8位的数据后列地址自动加1*/
			else
				WriteData(~*dp,1);	/*写数据到LCD,每写完一个8位的数据后列地址自动加1*/
			dp++;
		}
	}
	rt_pin_write(G12864_CS, PIN_HIGH);//CS1=1;
}

/*显示16x16点阵图像、汉字、生僻字或16x16点阵的其他图标*/
void display_graphic_11x11_1(Uchar reverse,Uchar page,Uchar column,Uchar *dp)
{
	Uchar i,j;

 	rt_pin_write(G12864_CS, PIN_LOW);//CS1=0;
	for(j=0;j<2;j++)
	{
		lcd_address(page+j,column);
		for (i=0;i<6;i++)
		{
			if(reverse==1)
				WriteData(*dp,1);		/*写数据到LCD,每写完一个8位的数据后列地址自动加1*/
			else
				WriteData(~*dp,1);	/*写数据到LCD,每写完一个8位的数据后列地址自动加1*/
			dp++;
		}
	}
	rt_pin_write(G12864_CS, PIN_HIGH);//CS1=1;
}

/*全屏清屏*/
void clear_screen()
{
	unsigned char i,j;
 	rt_pin_write(G12864_CS, PIN_LOW);//CS1=0;
 	for(i=0;i<9;i++)
	{
		lcd_address(1+i,1);
		for(j=0;j<132;j++)
		{
			WriteData(0x00,1);
		}
	}
 	rt_pin_write(G12864_CS, PIN_HIGH);//CS1=1;
}
#endif
////////////////// dianzhen end
///////////////////////////////////////////////////////////////////


////////////////////////////////////////////////
//// dianzhen qrcode begin
////////////////////////////////////////////////
#if 0
// QR Code Format Encoding
#define MODE_NUMERIC        0
#define MODE_ALPHANUMERIC   1
#define MODE_BYTE           2

// Error Correction Code Levels
#define ECC_LOW            0
#define ECC_MEDIUM         1
#define ECC_QUARTILE       2
#define ECC_HIGH           3


// If set to non-zero, this library can ONLY produce QR codes at that version
// This saves a lot of dynamic memory, as the codeword tables are skipped
#ifndef LOCK_VERSION
#define LOCK_VERSION       0
#endif


typedef struct QRCode {
    uint8_t version;
    uint8_t size;
    uint8_t ecc;
    uint8_t mode;
    uint8_t mask;
    uint8_t *modules;
} QRCode;

// #define DBG_ENABLE
// #define DBG_SECTION_NAME               "qrcode"
// #define DBG_LEVEL                      DBG_LOG
// #include <rtdbg.h>

// #include <stdlib.h>
// #include <string.h>

#if LOCK_VERSION == 0

static const uint16_t NUM_ERROR_CORRECTION_CODEWORDS[4][40] = {
    // 1,  2,  3,  4,  5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40    Error correction level
    { 10, 16, 26, 36, 48,  64,  72,  88, 110, 130, 150, 176, 198, 216, 240, 280, 308, 338, 364, 416, 442, 476, 504, 560,  588,  644,  700,  728,  784,  812,  868,  924,  980, 1036, 1064, 1120, 1204, 1260, 1316, 1372},  // Medium
    {  7, 10, 15, 20, 26,  36,  40,  48,  60,  72,  80,  96, 104, 120, 132, 144, 168, 180, 196, 224, 224, 252, 270, 300,  312,  336,  360,  390,  420,  450,  480,  510,  540,  570,  570,  600,  630,  660,  720,  750},  // Low
    { 17, 28, 44, 64, 88, 112, 130, 156, 192, 224, 264, 308, 352, 384, 432, 480, 532, 588, 650, 700, 750, 816, 900, 960, 1050, 1110, 1200, 1260, 1350, 1440, 1530, 1620, 1710, 1800, 1890, 1980, 2100, 2220, 2310, 2430},  // High
    { 13, 22, 36, 52, 72,  96, 108, 132, 160, 192, 224, 260, 288, 320, 360, 408, 448, 504, 546, 600, 644, 690, 750, 810,  870,  952, 1020, 1050, 1140, 1200, 1290, 1350, 1440, 1530, 1590, 1680, 1770, 1860, 1950, 2040},  // Quartile
};

static const uint8_t NUM_ERROR_CORRECTION_BLOCKS[4][40] = {
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    // 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    {  1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium
    {  1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low
    {  1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High
    {  1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile
};

static const uint16_t NUM_RAW_DATA_MODULES[40] = {
    //  1,   2,   3,   4,    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
      208, 359, 567, 807, 1079, 1383, 1568, 1936, 2336, 2768, 3232, 3728, 4256, 4651, 5243, 5867, 6523,
    //   18,   19,   20,   21,    22,    23,    24,    25,   26,    27,     28,    29,    30,    31,
       7211, 7931, 8683, 9252, 10068, 10916, 11796, 12708, 13652, 14628, 15371, 16411, 17483, 18587,
    //    32,    33,    34,    35,    36,    37,    38,    39,    40
       19723, 20891, 22091, 23008, 24272, 25568, 26896, 28256, 29648
};

// @TODO: Put other LOCK_VERSIONS here
#elif LOCK_VERSION == 3

static const int16_t NUM_ERROR_CORRECTION_CODEWORDS[4] = {
    26, 15, 44, 36
};

static const int8_t NUM_ERROR_CORRECTION_BLOCKS[4] = {
    1, 1, 2, 2
};

static const uint16_t NUM_RAW_DATA_MODULES = 567;

#else

#error Unsupported LOCK_VERSION (add it...)

#endif

static int max(int a, int b) {
    if (a > b) { return a; }
    return b;
}

static int8_t getAlphanumeric(char c) {

    if (c >= '0' && c <= '9') { return (c - '0'); }
    if (c >= 'A' && c <= 'Z') { return (c - 'A' + 10); }

    switch (c) {
        case ' ': return 36;
        case '$': return 37;
        case '%': return 38;
        case '*': return 39;
        case '+': return 40;
        case '-': return 41;
        case '.': return 42;
        case '/': return 43;
        case ':': return 44;
    }

    return -1;
}

static bool isAlphanumeric(const char *text, uint16_t length) {
    while (length != 0) {
        if (getAlphanumeric(text[--length]) == -1) { return false; }
    }
    return true;
}

static bool isNumeric(const char *text, uint16_t length) {
    while (length != 0) {
        char c = text[--length];
        if (c < '0' || c > '9') { return false; }
    }
    return true;
}

// We store the following tightly packed (less 8) in modeInfo
//               <=9  <=26  <= 40
// NUMERIC      ( 10,   12,    14);
// ALPHANUMERIC (  9,   11,    13);
// BYTE         (  8,   16,    16);
static char getModeBits(uint8_t version, uint8_t mode) {
    // Note: We use 15 instead of 16; since 15 doesn't exist and we cannot store 16 (8 + 8) in 3 bits
    // hex(int("".join(reversed([('00' + bin(x - 8)[2:])[-3:] for x in [10, 9, 8, 12, 11, 15, 14, 13, 15]])), 2))
    unsigned int modeInfo = 0x7bbb80a;

#if LOCK_VERSION == 0 || LOCK_VERSION > 9
    if (version > 9) { modeInfo >>= 9; }
#endif

#if LOCK_VERSION == 0 || LOCK_VERSION > 26
    if (version > 26) { modeInfo >>= 9; }
#endif

    char result = 8 + ((modeInfo >> (3 * mode)) & 0x07);
    if (result == 15) { result = 16; }

    return result;
}

typedef struct BitBucket {
    uint32_t bitOffsetOrWidth;
    uint16_t capacityBytes;
    uint8_t *data;
} BitBucket;

static uint16_t bb_getGridSizeBytes(uint8_t size) {
    return (((size * size) + 7) / 8);
}

static uint16_t bb_getBufferSizeBytes(uint32_t bits) {
    return ((bits + 7) / 8);
}

static void bb_initBuffer(BitBucket *bitBuffer, uint8_t *data, int32_t capacityBytes) {
    bitBuffer->bitOffsetOrWidth = 0;
    bitBuffer->capacityBytes = capacityBytes;
    bitBuffer->data = data;

    memset(data, 0, bitBuffer->capacityBytes);
}

static void bb_initGrid(BitBucket *bitGrid, uint8_t *data, uint8_t size) {
    bitGrid->bitOffsetOrWidth = size;
    bitGrid->capacityBytes = bb_getGridSizeBytes(size);
    bitGrid->data = data;

    memset(data, 0, bitGrid->capacityBytes);
}

static void bb_appendBits(BitBucket *bitBuffer, uint32_t val, uint8_t length) {
    uint32_t offset = bitBuffer->bitOffsetOrWidth;
    for (int8_t i = length - 1; i >= 0; i--, offset++) {
        if (bitBuffer->capacityBytes > offset >> 3) {
            bitBuffer->data[offset >> 3] |= ((val >> i) & 1) << (7 - (offset & 7));
        }
    }
    bitBuffer->bitOffsetOrWidth = offset;
}

static void bb_setBit(BitBucket *bitGrid, uint8_t x, uint8_t y, bool on) {
    uint32_t offset = y * bitGrid->bitOffsetOrWidth + x;
    uint8_t mask = 1 << (7 - (offset & 0x07));
    if (on) {
        bitGrid->data[offset >> 3] |= mask;
    } else {
        bitGrid->data[offset >> 3] &= ~mask;
    }
}

static void bb_invertBit(BitBucket *bitGrid, uint8_t x, uint8_t y, bool invert) {
    uint32_t offset = y * bitGrid->bitOffsetOrWidth + x;
    uint8_t mask = 1 << (7 - (offset & 0x07));
    bool on = ((bitGrid->data[offset >> 3] & (1 << (7 - (offset & 0x07)))) != 0);
    if (on ^ invert) {
        bitGrid->data[offset >> 3] |= mask;
    } else {
        bitGrid->data[offset >> 3] &= ~mask;
    }
}

static bool bb_getBit(BitBucket *bitGrid, uint8_t x, uint8_t y) {
    uint32_t offset = y * bitGrid->bitOffsetOrWidth + x;
    return (bitGrid->data[offset >> 3] & (1 << (7 - (offset & 0x07)))) != 0;
}

// XORs the data modules in this QR Code with the given mask pattern. Due to XOR's mathematical
// properties, calling applyMask(m) twice with the same value is equivalent to no change at all.
// This means it is possible to apply a mask, undo it, and try another mask. Note that a final
// well-formed QR Code symbol needs exactly one mask applied (not zero, not two, etc.).
static void applyMask(BitBucket *modules, BitBucket *isFunction, uint8_t mask) {
    uint8_t size = modules->bitOffsetOrWidth;

    for (uint8_t y = 0; y < size; y++) {
        for (uint8_t x = 0; x < size; x++) {
            if (bb_getBit(isFunction, x, y)) { continue; }

            bool invert = 0;
            switch (mask) {
                case 0:  invert = (x + y) % 2 == 0;                    break;
                case 1:  invert = y % 2 == 0;                          break;
                case 2:  invert = x % 3 == 0;                          break;
                case 3:  invert = (x + y) % 3 == 0;                    break;
                case 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;
                case 5:  invert = x * y % 2 + x * y % 3 == 0;          break;
                case 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;
                case 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;
            }
            bb_invertBit(modules, x, y, invert);
        }
    }
}

static void setFunctionModule(BitBucket *modules, BitBucket *isFunction, uint8_t x, uint8_t y, bool on) {
    bb_setBit(modules, x, y, on);
    bb_setBit(isFunction, x, y, true);
}

// Draws a 9*9 finder pattern including the border separator, with the center module at (x, y).
static void drawFinderPattern(BitBucket *modules, BitBucket *isFunction, uint8_t x, uint8_t y) {
    uint8_t size = modules->bitOffsetOrWidth;

    for (int8_t i = -4; i <= 4; i++) {
        for (int8_t j = -4; j <= 4; j++) {
            uint8_t dist = max(abs(i), abs(j));  // Chebyshev/infinity norm
            int16_t xx = x + j, yy = y + i;
            if (0 <= xx && xx < size && 0 <= yy && yy < size) {
                setFunctionModule(modules, isFunction, xx, yy, dist != 2 && dist != 4);
            }
        }
    }
}

// Draws a 5*5 alignment pattern, with the center module at (x, y).
static void drawAlignmentPattern(BitBucket *modules, BitBucket *isFunction, uint8_t x, uint8_t y) {
    for (int8_t i = -2; i <= 2; i++) {
        for (int8_t j = -2; j <= 2; j++) {
            setFunctionModule(modules, isFunction, x + j, y + i, max(abs(i), abs(j)) != 1);
        }
    }
}

// Draws two copies of the format bits (with its own error correction code)
// based on the given mask and this object's error correction level field.
static void drawFormatBits(BitBucket *modules, BitBucket *isFunction, uint8_t ecc, uint8_t mask) {

    uint8_t size = modules->bitOffsetOrWidth;

    // Calculate error correction code and pack bits
    uint32_t data = ecc << 3 | mask;  // errCorrLvl is uint2, mask is uint3
    uint32_t rem = data;
    for (int i = 0; i < 10; i++) {
        rem = (rem << 1) ^ ((rem >> 9) * 0x537);
    }

    data = data << 10 | rem;
    data ^= 0x5412;  // uint15

    // Draw first copy
    for (uint8_t i = 0; i <= 5; i++) {
        setFunctionModule(modules, isFunction, 8, i, ((data >> i) & 1) != 0);
    }

    setFunctionModule(modules, isFunction, 8, 7, ((data >> 6) & 1) != 0);
    setFunctionModule(modules, isFunction, 8, 8, ((data >> 7) & 1) != 0);
    setFunctionModule(modules, isFunction, 7, 8, ((data >> 8) & 1) != 0);

    for (int8_t i = 9; i < 15; i++) {
        setFunctionModule(modules, isFunction, 14 - i, 8, ((data >> i) & 1) != 0);
    }

    // Draw second copy
    for (int8_t i = 0; i <= 7; i++) {
        setFunctionModule(modules, isFunction, size - 1 - i, 8, ((data >> i) & 1) != 0);
    }

    for (int8_t i = 8; i < 15; i++) {
        setFunctionModule(modules, isFunction, 8, size - 15 + i, ((data >> i) & 1) != 0);
    }

    setFunctionModule(modules, isFunction, 8, size - 8, true);
}

// Draws two copies of the version bits (with its own error correction code),
// based on this object's version field (which only has an effect for 7 <= version <= 40).
static void drawVersion(BitBucket *modules, BitBucket *isFunction, uint8_t version) {

    int8_t size = modules->bitOffsetOrWidth;

#if LOCK_VERSION != 0 && LOCK_VERSION < 7
    return;

#else
    if (version < 7) { return; }

    // Calculate error correction code and pack bits
    uint32_t rem = version;  // version is uint6, in the range [7, 40]
    for (uint8_t i = 0; i < 12; i++) {
        rem = (rem << 1) ^ ((rem >> 11) * 0x1F25);
    }

    uint32_t data = version << 12 | rem;  // uint18

    // Draw two copies
    for (uint8_t i = 0; i < 18; i++) {
        bool bit = ((data >> i) & 1) != 0;
        uint8_t a = size - 11 + i % 3, b = i / 3;
        setFunctionModule(modules, isFunction, a, b, bit);
        setFunctionModule(modules, isFunction, b, a, bit);
    }

#endif
}

static void drawFunctionPatterns(BitBucket *modules, BitBucket *isFunction, uint8_t version, uint8_t ecc) {

    uint8_t size = modules->bitOffsetOrWidth;

    // Draw the horizontal and vertical timing patterns
    for (uint8_t i = 0; i < size; i++) {
        setFunctionModule(modules, isFunction, 6, i, i % 2 == 0);
        setFunctionModule(modules, isFunction, i, 6, i % 2 == 0);
    }

    // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
    drawFinderPattern(modules, isFunction, 3, 3);
    drawFinderPattern(modules, isFunction, size - 4, 3);
    drawFinderPattern(modules, isFunction, 3, size - 4);

#if LOCK_VERSION == 0 || LOCK_VERSION > 1

    if (version > 1) {

        // Draw the numerous alignment patterns

        uint8_t alignCount = version / 7 + 2;
        uint8_t step;
        if (version != 32) {
            step = (version * 4 + alignCount * 2 + 1) / (2 * alignCount - 2) * 2;  // ceil((size - 13) / (2*numAlign - 2)) * 2
        } else { // C-C-C-Combo breaker!
            step = 26;
        }

        uint8_t alignPositionIndex = alignCount - 1;
        uint8_t *alignPosition = (uint8_t *)rt_calloc(1, alignCount);
        if (!alignPosition) {
            LOG_W("No Memory");
            return;
        }

        alignPosition[0] = 6;

        uint8_t size = version * 4 + 17;
        for (uint8_t i = 0, pos = size - 7; i < alignCount - 1; i++, pos -= step) {
            alignPosition[alignPositionIndex--] = pos;
        }

        for (uint8_t i = 0; i < alignCount; i++) {
            for (uint8_t j = 0; j < alignCount; j++) {
                if ((i == 0 && j == 0) || (i == 0 && j == alignCount - 1) || (i == alignCount - 1 && j == 0)) {
                    continue;  // Skip the three finder corners
                } else {
                    drawAlignmentPattern(modules, isFunction, alignPosition[i], alignPosition[j]);
                }
            }
        }
        rt_free(alignPosition);
}

#endif

    // Draw configuration data
    drawFormatBits(modules, isFunction, ecc, 0);  // Dummy mask value; overwritten later in the constructor
    drawVersion(modules, isFunction, version);
}


// Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
// data area of this QR Code symbol. Function modules need to be marked off before this is called.
static void drawCodewords(BitBucket *modules, BitBucket *isFunction, BitBucket *codewords) {

    uint32_t bitLength = codewords->bitOffsetOrWidth;
    uint8_t *data = codewords->data;

    uint8_t size = modules->bitOffsetOrWidth;

    // Bit index into the data
    uint32_t i = 0;

    // Do the funny zigzag scan
    for (int16_t right = size - 1; right >= 1; right -= 2) {  // Index of right column in each column pair
        if (right == 6) { right = 5; }

        for (uint8_t vert = 0; vert < size; vert++) {  // Vertical counter
            for (int j = 0; j < 2; j++) {
                uint8_t x = right - j;  // Actual x coordinate
                bool upwards = ((right & 2) == 0) ^ (x < 6);
                uint8_t y = upwards ? size - 1 - vert : vert;  // Actual y coordinate
                if (!bb_getBit(isFunction, x, y) && i < bitLength) {
                    bb_setBit(modules, x, y, ((data[i >> 3] >> (7 - (i & 7))) & 1) != 0);
                    i++;
                }
                // If there are any remainder bits (0 to 7), they are already
                // set to 0/false/white when the grid of modules was initialized
            }
        }
    }
}

#define PENALTY_N1      3
#define PENALTY_N2      3
#define PENALTY_N3     40
#define PENALTY_N4     10

// Calculates and returns the penalty score based on state of this QR Code's current modules.
// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
// @TODO: This can be optimized by working with the bytes instead of bits.
static uint32_t getPenaltyScore(BitBucket *modules) {
    uint32_t result = 0;

    uint8_t size = modules->bitOffsetOrWidth;

    // Adjacent modules in row having same color
    for (uint8_t y = 0; y < size; y++) {

        bool colorX = bb_getBit(modules, 0, y);
        for (uint8_t x = 1, runX = 1; x < size; x++) {
            bool cx = bb_getBit(modules, x, y);
            if (cx != colorX) {
                colorX = cx;
                runX = 1;

            } else {
                runX++;
                if (runX == 5) {
                    result += PENALTY_N1;
                } else if (runX > 5) {
                    result++;
                }
            }
        }
    }

    // Adjacent modules in column having same color
    for (uint8_t x = 0; x < size; x++) {
        bool colorY = bb_getBit(modules, x, 0);
        for (uint8_t y = 1, runY = 1; y < size; y++) {
            bool cy = bb_getBit(modules, x, y);
            if (cy != colorY) {
                colorY = cy;
                runY = 1;
            } else {
                runY++;
                if (runY == 5) {
                    result += PENALTY_N1;
                } else if (runY > 5) {
                    result++;
                }
            }
        }
    }

    uint16_t black = 0;
    for (uint8_t y = 0; y < size; y++) {
        uint16_t bitsRow = 0, bitsCol = 0;
        for (uint8_t x = 0; x < size; x++) {
            bool color = bb_getBit(modules, x, y);

            // 2*2 blocks of modules having same color
            if (x > 0 && y > 0) {
                bool colorUL = bb_getBit(modules, x - 1, y - 1);
                bool colorUR = bb_getBit(modules, x, y - 1);
                bool colorL = bb_getBit(modules, x - 1, y);
                if (color == colorUL && color == colorUR && color == colorL) {
                    result += PENALTY_N2;
                }
            }

            // Finder-like pattern in rows and columns
            bitsRow = ((bitsRow << 1) & 0x7FF) | color;
            bitsCol = ((bitsCol << 1) & 0x7FF) | bb_getBit(modules, y, x);

            // Needs 11 bits accumulated
            if (x >= 10) {
                if (bitsRow == 0x05D || bitsRow == 0x5D0) {
                    result += PENALTY_N3;
                }
                if (bitsCol == 0x05D || bitsCol == 0x5D0) {
                    result += PENALTY_N3;
                }
            }

            // Balance of black and white modules
            if (color) { black++; }
        }
    }

    // Find smallest k such that (45-5k)% <= dark/total <= (55+5k)%
    uint16_t total = size * size;
    for (uint16_t k = 0; black * 20 < (9 - k) * total || black * 20 > (11 + k) * total; k++) {
        result += PENALTY_N4;
    }

    return result;
}

static uint8_t rs_multiply(uint8_t x, uint8_t y) {
    // Russian peasant multiplication
    // See: https://en.wikipedia.org/wiki/Ancient_Egyptian_multiplication
    uint16_t z = 0;
    for (int8_t i = 7; i >= 0; i--) {
        z = (z << 1) ^ ((z >> 7) * 0x11D);
        z ^= ((y >> i) & 1) * x;
    }
    return z;
}

static void rs_init(uint8_t degree, uint8_t *coeff) {
    memset(coeff, 0, degree);
    coeff[degree - 1] = 1;

    // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
    // drop the highest term, and store the rest of the coefficients in order of descending powers.
    // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
    uint16_t root = 1;
    for (uint8_t i = 0; i < degree; i++) {
        // Multiply the current product by (x - r^i)
        for (uint8_t j = 0; j < degree; j++) {
            coeff[j] = rs_multiply(coeff[j], root);
            if (j + 1 < degree) {
                coeff[j] ^= coeff[j + 1];
            }
        }
        root = (root << 1) ^ ((root >> 7) * 0x11D);  // Multiply by 0x02 mod GF(2^8/0x11D)
    }
}

static void rs_getRemainder(uint8_t degree, uint8_t *coeff, uint8_t *data, uint8_t length, uint8_t *result, uint8_t stride) {
    // Compute the remainder by performing polynomial division

    //for (uint8_t i = 0; i < degree; i++) { result[] = 0; }
    //memset(result, 0, degree);

    for (uint8_t i = 0; i < length; i++) {
        uint8_t factor = data[i] ^ result[0];
        for (uint8_t j = 1; j < degree; j++) {
            result[(j - 1) * stride] = result[j * stride];
        }
        result[(degree - 1) * stride] = 0;

        for (uint8_t j = 0; j < degree; j++) {
            result[j * stride] ^= rs_multiply(coeff[j], factor);
        }
    }
}

static int8_t encodeDataCodewords(BitBucket *dataCodewords, const uint8_t *text, uint16_t length, uint8_t version) {
    int8_t mode = MODE_BYTE;

    if (isNumeric((char*)text, length)) {
        mode = MODE_NUMERIC;
        bb_appendBits(dataCodewords, 1 << MODE_NUMERIC, 4);
        bb_appendBits(dataCodewords, length, getModeBits(version, MODE_NUMERIC));

        uint16_t accumData = 0;
        uint8_t accumCount = 0;
        for (uint16_t i = 0; i < length; i++) {
            accumData = accumData * 10 + ((char)(text[i]) - '0');
            accumCount++;
            if (accumCount == 3) {
                bb_appendBits(dataCodewords, accumData, 10);
                accumData = 0;
                accumCount = 0;
            }
        }

        // 1 or 2 digits remaining
        if (accumCount > 0) {
            bb_appendBits(dataCodewords, accumData, accumCount * 3 + 1);
        }

    } else if (isAlphanumeric((char*)text, length)) {
        mode = MODE_ALPHANUMERIC;
        bb_appendBits(dataCodewords, 1 << MODE_ALPHANUMERIC, 4);
        bb_appendBits(dataCodewords, length, getModeBits(version, MODE_ALPHANUMERIC));

        uint16_t accumData = 0;
        uint8_t accumCount = 0;
        for (uint16_t i = 0; i  < length; i++) {
            accumData = accumData * 45 + getAlphanumeric((char)(text[i]));
            accumCount++;
            if (accumCount == 2) {
                bb_appendBits(dataCodewords, accumData, 11);
                accumData = 0;
                accumCount = 0;
            }
        }

        // 1 character remaining
        if (accumCount > 0) {
            bb_appendBits(dataCodewords, accumData, 6);
        }

    } else {
        bb_appendBits(dataCodewords, 1 << MODE_BYTE, 4);
        bb_appendBits(dataCodewords, length, getModeBits(version, MODE_BYTE));
        for (uint16_t i = 0; i < length; i++) {
            bb_appendBits(dataCodewords, (char)(text[i]), 8);
        }
    }

    //bb_setBits(dataCodewords, length, 4, getModeBits(version, mode));

    return mode;
}

static void performErrorCorrection(uint8_t version, uint8_t ecc, BitBucket *data) {

    // See: http://www.thonky.com/qr-code-tutorial/structure-final-message

#if LOCK_VERSION == 0
    uint8_t numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecc][version - 1];
    uint16_t totalEcc = NUM_ERROR_CORRECTION_CODEWORDS[ecc][version - 1];
    uint16_t moduleCount = NUM_RAW_DATA_MODULES[version - 1];
#else
    uint8_t numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecc];
    uint16_t totalEcc = NUM_ERROR_CORRECTION_CODEWORDS[ecc];
    uint16_t moduleCount = NUM_RAW_DATA_MODULES;
#endif

    uint8_t blockEccLen = totalEcc / numBlocks;
    uint8_t numShortBlocks = numBlocks - moduleCount / 8 % numBlocks;
    uint8_t shortBlockLen = moduleCount / 8 / numBlocks;

    uint8_t shortDataBlockLen = shortBlockLen - blockEccLen;

    uint8_t *result = (uint8_t *)rt_calloc(1, data->capacityBytes);
    uint8_t *coeff = (uint8_t *)rt_calloc(1, blockEccLen);
    if (!result || !coeff) {
        LOG_W("No Memory");
        rt_free(result);
        rt_free(coeff);
        return;
    }
    rs_init(blockEccLen, coeff);

    uint16_t offset = 0;
    uint8_t *dataBytes = data->data;

    // Interleave all short blocks
    for (uint8_t i = 0; i < shortDataBlockLen; i++) {
        uint16_t index = i;
        uint8_t stride = shortDataBlockLen;
        for (uint8_t blockNum = 0; blockNum < numBlocks; blockNum++) {
            result[offset++] = dataBytes[index];

#if LOCK_VERSION == 0 || LOCK_VERSION >= 5
            if (blockNum == numShortBlocks) { stride++; }
#endif
            index += stride;
        }
    }

    // Version less than 5 only have short blocks
#if LOCK_VERSION == 0 || LOCK_VERSION >= 5
    {
        // Interleave long blocks
        uint16_t index = shortDataBlockLen * (numShortBlocks + 1);
        uint8_t stride = shortDataBlockLen;
        for (uint8_t blockNum = 0; blockNum < numBlocks - numShortBlocks; blockNum++) {
            result[offset++] = dataBytes[index];

            if (blockNum == 0) { stride++; }
            index += stride;
        }
    }
#endif

    // Add all ecc blocks, interleaved
    uint8_t blockSize = shortDataBlockLen;
    for (uint8_t blockNum = 0; blockNum < numBlocks; blockNum++) {

#if LOCK_VERSION == 0 || LOCK_VERSION >= 5
        if (blockNum == numShortBlocks) { blockSize++; }
#endif
        rs_getRemainder(blockEccLen, coeff, dataBytes, blockSize, &result[offset + blockNum], numBlocks);
        dataBytes += blockSize;
    }

    memcpy(data->data, result, data->capacityBytes);
    data->bitOffsetOrWidth = moduleCount;

    rt_free(result);
    rt_free(coeff);
}

// We store the Format bits tightly packed into a single byte (each of the 4 modes is 2 bits)
// The format bits can be determined by ECC_FORMAT_BITS >> (2 * ecc)
static const uint8_t ECC_FORMAT_BITS = (0x02 << 6) | (0x03 << 4) | (0x00 << 2) | (0x01 << 0);

uint16_t qrcode_getBufferSize(uint8_t version) {
    return bb_getGridSizeBytes(4 * version + 17);
}

int8_t qrcode_initBytes(QRCode *qrcode, uint8_t *modules, uint8_t version, uint8_t ecc, uint8_t *data, uint16_t length) {
    uint8_t size = version * 4 + 17;
    qrcode->version = version;
    qrcode->size = size;
    qrcode->ecc = ecc;
    qrcode->modules = modules;

    uint8_t eccFormatBits = (ECC_FORMAT_BITS >> (2 * ecc)) & 0x03;

#if LOCK_VERSION == 0
    uint16_t moduleCount = NUM_RAW_DATA_MODULES[version - 1];
    uint16_t dataCapacity = moduleCount / 8 - NUM_ERROR_CORRECTION_CODEWORDS[eccFormatBits][version - 1];
#else
    version = LOCK_VERSION;
    uint16_t moduleCount = NUM_RAW_DATA_MODULES;
    uint16_t dataCapacity = moduleCount / 8 - NUM_ERROR_CORRECTION_CODEWORDS[eccFormatBits];
#endif

    struct BitBucket codewords;
    uint8_t *codewordBytes = (uint8_t *)rt_calloc(1, bb_getBufferSizeBytes(moduleCount));
    if (!codewordBytes) {
        LOG_W("No Memory");
        return -RT_ENOMEM;
    }
    bb_initBuffer(&codewords, codewordBytes, (int32_t)bb_getBufferSizeBytes(moduleCount));

    // Place the data code words into the buffer
    int8_t mode = encodeDataCodewords(&codewords, data, length, version);

    if (mode < 0) { return -1; }
    qrcode->mode = mode;

    // Add terminator and pad up to a byte if applicable
    int32_t padding = (dataCapacity * 8) - codewords.bitOffsetOrWidth;
    if (padding < 0) { return -1; }
    if (padding > 4) { padding = 4; }
    bb_appendBits(&codewords, 0, padding);
    bb_appendBits(&codewords, 0, (8 - codewords.bitOffsetOrWidth % 8) % 8);

    // Pad with alternate bytes until data capacity is reached
    for (uint8_t padByte = 0xEC; codewords.bitOffsetOrWidth < (dataCapacity * 8); padByte ^= 0xEC ^ 0x11) {
        bb_appendBits(&codewords, padByte, 8);
    }

    BitBucket modulesGrid;
    bb_initGrid(&modulesGrid, modules, size);

    BitBucket isFunctionGrid;
    uint8_t *isFunctionGridBytes = (uint8_t *)rt_calloc(1, bb_getGridSizeBytes(size));
    if (!isFunctionGridBytes) {
        LOG_W("No Memory");
        return -RT_ENOMEM;
    }
    bb_initGrid(&isFunctionGrid, isFunctionGridBytes, size);

    drawFunctionPatterns(&modulesGrid, &isFunctionGrid, version, eccFormatBits);
    performErrorCorrection(version, eccFormatBits, &codewords);
    drawCodewords(&modulesGrid, &isFunctionGrid, &codewords);

    // Find the best (lowest penalty) mask
    uint8_t mask = 0;
    int32_t minPenalty = INT32_MAX;
    for (uint8_t i = 0; i < 8; i++) {
        drawFormatBits(&modulesGrid, &isFunctionGrid, eccFormatBits, i);
        applyMask(&modulesGrid, &isFunctionGrid, i);
        int penalty = getPenaltyScore(&modulesGrid);
        if (penalty < minPenalty) {
            mask = i;
            minPenalty = penalty;
        }
        applyMask(&modulesGrid, &isFunctionGrid, i);  // Undoes the mask due to XOR
    }

    qrcode->mask = mask;

    // Overwrite old format bits
    drawFormatBits(&modulesGrid, &isFunctionGrid, eccFormatBits, mask);

    // Apply the final choice of mask
    applyMask(&modulesGrid, &isFunctionGrid, mask);

    rt_free(isFunctionGridBytes);
    rt_free(codewordBytes);
    return 0;
}

int8_t qrcode_initText(QRCode *qrcode, uint8_t *modules, uint8_t version, uint8_t ecc, const char *data) {
    return qrcode_initBytes(qrcode, modules, version, ecc, (uint8_t*)data, strlen(data));
}

bool qrcode_getModule(QRCode *qrcode, uint8_t x, uint8_t y) {
    if (x >= qrcode->size || y >= qrcode->size) {
        return false;
    }

    uint32_t offset = y * qrcode->size + x;
    return (qrcode->modules[offset >> 3] & (1 << (7 - (offset & 0x07)))) != 0;
}


static void qrcode()
{
#define DEFAULT_QR_VERSION 3
#define DEFAULT_QR_STRING "HELLO WORLD"

    QRCode qrc;
    uint8_t x, y, *qrcodeBytes = (uint8_t *)rt_calloc(1, qrcode_getBufferSize(DEFAULT_QR_VERSION));
    int8_t result;
    char *qrstr = DEFAULT_QR_STRING;

    if (qrcodeBytes)
    {
        // if (argc > 1)
        // {
        //     qrstr = argv[1];
        // }

        result = qrcode_initText(&qrc, qrcodeBytes, DEFAULT_QR_VERSION, ECC_LOW, qrstr);
        rt_kprintf("result=%d, size=%d\n", result, qrc.size);

        if (result >= 0)
        {
            rt_kprintf("\n");
            for (y = 0; y < qrc.size; y++)
            {
                for (x = 0; x < qrc.size; x++)
                {
                    if (qrcode_getModule(&qrc, x, y))
                    {
                        //rt_kprintf("\xdb\xdb");
                        rt_kprintf("1");
                    }
                    else
                    {
                        //rt_kprintf("  ");
                        rt_kprintf("0");
                    }
                }
                rt_kprintf("\n");
            }

            uint8_t page = (qrc.size+8-1)/8; //向上取整
            rt_kprintf("write lcd, page=%d, qrc.size=%d\n", page, qrc.size);
            uint8_t *qrcodeArray = (uint8_t *)rt_calloc(1, qrc.size*page);//保存点阵二维码数组
            uint8_t *p = qrcodeArray;
            //uint8_t qrcodeArray[qrc.size*page]={0};
            //uint16_t cnt=0;
            uint8_t i=0;
            uint8_t shift=0;
            for(i=0; i<page; i++)
            {
                for (x = 0; x < qrc.size; x++)
                {
                    shift=0;
                    for (y = i*8; y < (i+1)*8; y++)
                    {
                        if (qrcode_getModule(&qrc, x, y))
                        {
                            //打点
                            *p = *p | (1<<shift);
                        }
                        else
                        {
                            //留白
                            *p = *p & ~(1<<shift);
                        }
                        shift++;
                    }
                    rt_kprintf("%02x ", *p);
                    p++;
                }
                rt_kprintf("\n");
            }
            clear_screen();
            DispQrcode(page, qrc.size, qrcodeArray);
            //DispQrcode48(qrcode48);
        }
        else
        {
            rt_kprintf("QR CODE(%s) General FAILED(%d)\n", qrstr, result);
        }
        rt_free(qrcodeBytes);
    }
    else
    {
        rt_kprintf("Warning: no memory!\n");
    }
}
#endif
///////////// dianzhen qrcode end
///////////////////////////////////////


#if 0
/////////////////////////////////////////
////////// duanma download begin， 网上下载的试验代码
//1621初始化
void ht1621_init(void)
{
    rt_kprintf("ht1621_init\n");
    rt_pin_mode(HT1621_CS, PIN_MODE_OUTPUT);
    rt_hw_us_delay(10);
    rt_pin_mode(HT1621_WR, PIN_MODE_OUTPUT);
    rt_hw_us_delay(10);
    rt_pin_mode(HT1621_DATA, PIN_MODE_OUTPUT);
    rt_hw_us_delay(10);
}
void lcd_init(void)
{
    rt_kprintf("lcd_init\n");
    //////////////////////////////////////////////////////
    rt_pin_write(HT1621_CS, PIN_HIGH);//GPIO_SetBits(GPIOA, HT1621_CS);
    rt_pin_write(HT1621_WR, PIN_HIGH);//GPIO_SetBits(GPIOB, HT1621_WR);
    rt_pin_write(HT1621_DATA, PIN_HIGH);//GPIO_SetBits(GPIOB, HT1621_DATA);
    rt_hw_us_delay(10);//for (ii=0;ii<10000;ii++){for(j=10;j>0;j--);}
    //////////////////////////////////////////////////////
    rt_pin_write(HT1621_CS, PIN_LOW);//GPIO_ResetBits(GPIOA, HT1621_CS);        //CS = 0;
    rt_hw_us_delay(10);//for (ii=0;ii<10000;ii++){for(j=10;j>0;j--);}
    write_mode(COMMAND);    //命令模式
    write_command(0x01);    //Enable System
    write_command(0x03);    //Enable Bias
    write_command(0x04);    //Disable Timer
    write_command(0x05);    //Disable WDT
    write_command(0x08);    //Tone OFF
    write_command(0x18);    //on-chip RC震荡
    write_command(0x29);    //1/4Duty 1/3Bias
    write_command(0x80);    //Disable IRQ
    write_command(0x40);    //Tone Frequency 4kHZ
    write_command(0xE0);    //Normal Mode
    rt_pin_write(HT1621_CS, PIN_HIGH);//GPIO_SetBits(GPIOA, HT1621_CS);  //CS = 1;
}
//写数据测试
// void write_addr_dat_n_test(unsigned char _addr, unsigned char _dat, unsigned char state)
// {
//     unsigned char i = 0;
//     unsigned char _dat_temp1,_dat_temp2;

//     rt_pin_write(HT1621_CS, PIN_LOW);//GPIO_ResetBits(GPIOA, HT1621_CS);                                // CS = 0;
//     write_mode(DAT);

//     _dat_temp1=Lcdram[_addr];
//     if(state==1)
//     {
//         _dat_temp2=(_dat_temp1|_dat);
//     }
//     else if(state==0)
//     {
//         _dat_temp2=(_dat_temp1&(~_dat));
//     }

//     write_address(_addr);

//     for (i = 0; i < 1; i++)
//     {
//         write_data_4bit(_dat_temp2);
//     }

//     rt_pin_write(HT1621_CS, PIN_HIGH);//GPIO_SetBits(GPIOA, HT1621_CS);                                    //CS = 1;

//     WriteLcdram(_addr, _dat_temp2);
// }
///////////////  duanma download end
/////////////////////////////////////////
#endif

int main(void)
{
    /*启动独立watch dog*/
    //iwdg_start(1000);
// rt_kprintf("main start 29!\n");
// uint8_t ttt=9;
// uint8_t page = (ttt+8-1)/8;
// rt_kprintf("page=%d\n", page);
// ttt=17;
// page = (ttt+8-1)/8;
// rt_kprintf("page=%d\n", page);

#if 0 //test code
    uint8_t recv_data[50] = "goiot:192.168.0.171:192.168.0.25";
    char *token;
    uint8_t goiot[10]={0};
    uint8_t appIP[20]={0};
    uint8_t cpIP[20]={0};
    token = strtok(recv_data, ":");
    if(token!=NULL)
        strcpy(goiot, token);
    token = strtok(NULL, ":");
    if(token!=NULL)
        strcpy(appIP, token);
    token = strtok(NULL, ":");
    if(token!=NULL)
        strcpy(cpIP, token);

    rt_kprintf("%s\n", recv_data);
    rt_kprintf("%s\n", goiot);
    rt_kprintf("%s\n", appIP);
    rt_kprintf("%s\n", cpIP);
#endif

#if 0 //dianzhenqrcode
    qrcode();
    while(1);
#endif

#if 1 //duanma
    //mengma code
	LcdInit();
    //SwitchToUi_PowerOn();
    //SwitchToUi_Standby();
    //LcdDisplayAll();
    uint8_t rtcTime[7] = {0};

    //LcdAllOff();
    while(1)
    {
        rt_thread_mdelay(1*1000);
    LcdAllOn();
    }
    //Ht1621WriteSegVal(16, 1);
    // Ht1621WriteSegVal(16, 2);
    // Ht1621WriteSegVal(16, 4);
    // Ht1621WriteSegVal(16, 8);
    // Ht1621WriteSegVal(17, 1);
    // Ht1621WriteSegVal(17, 2);
    // Ht1621WriteSegVal(17, 4);
    // Ht1621WriteSegVal(17, 8);
    //LcdDisplaySocketFault(LCD_DISPLAY);
    // LcdDisplayEight(1);
    // LcdDisplayEight(2);
    // LcdDisplayEight(3);
    // LcdDisplayEight(4);
    // LcdDisplayEight(5);
    // LcdDisplayEight(6);
    // LcdDisplayEight(7);
    // LcdDisplayEight(8);
    // LcdDisplayEight(9);
    // LcdDisplayEight(10);
    //Ht1621WriteAllSegVal(0xff, 128);

    //download
    //ht1621_init();
    //lcd_init();
    //write_addr_dat_n_test(0x01, 0x0f, 0);

    while(0)
    {
        rt_kprintf("ui loop\n");
        UiProgressLoop();

        //LcdDisplayZero(7);
        //rt_thread_mdelay(1000);
        //rt_kprintf("ui loop\n");
        // rt_hw_us_delay(10);
        //rt_pin_write(HT1621_CS, PIN_LOW); 
        // rt_hw_us_delay(10);
        // rt_pin_write(HT1621_CS, PIN_LOW);
        // rt_pin_write(HT1621_RD, PIN_LOW);
        //rt_pin_write(HT1621_WR, PIN_LOW);
        //rt_pin_write(HT1621_DATA, PIN_LOW);
        //Ht1621_CS_0();
        //Ht1621_RD_0();
        //Ht1621_WR_0();
        //Ht1621_DATA_0();
        //rt_thread_mdelay(1000);
        //rt_pin_write(HT1621_CS, PIN_HIGH);
        //rt_pin_write(HT1621_RD, PIN_HIGH);
        //rt_pin_write(HT1621_WR, PIN_HIGH);
        //rt_pin_write(HT1621_DATA, PIN_HIGH);
        //Ht1621_CS_1();
        //Ht1621_RD_1();
        //Ht1621_WR_1();
        //Ht1621_DATA_1();
        rt_thread_mdelay(1000);
    }
#endif

#if 0 //dianzhen
    Init_lcd();
    while(1)
    {
        clear_screen();
        qrcode();
        while(1);

        DispQrcode64(qrcode64);
        rt_thread_mdelay(1000);//M_Delay(600);

        clear_screen();
        DispQrcode48(qrcode48);
        rt_thread_mdelay(1000);//M_Delay(600);

        clear_screen();
        Dispgraphic(map);
        rt_thread_mdelay(1000);//M_Delay(600);

        clear_screen();
        Dispgraphic(map5);
        rt_thread_mdelay(1000);//M_Delay(600);

        Dispgraphic(map1);
        rt_thread_mdelay(1000);//M_Delay(600);

        WriteData(0xa7,0);
        rt_thread_mdelay(1000);//M_Delay(600);

        WriteData(0xa6,0);
        rt_thread_mdelay(1000);//M_Delay(600);

        Dispgraphic(map2);
        rt_thread_mdelay(1000);//M_Delay(600);

        Displine(snow);
        rt_thread_mdelay(1000);//M_Delay(600);

        Displine(black);
        rt_thread_mdelay(1000);//M_Delay(600);

        Displine(clear);
        rt_thread_mdelay(1000);//M_Delay(600);

        Dispgraphic(map3);
        rt_thread_mdelay(1000);//M_Delay(600);

        Dispgraphic(map6);
        rt_thread_mdelay(2000);//M_Delay(600);

        clear_screen();

        display_graphic_16x16_2(1,1,1,ye); /*在第1页，第1列显示单个汉字"液"*/
        display_graphic_16x16_2(1,1,(1+16),jing);
        display_graphic_16x16_2(1,1,(1+32),xian);
        display_graphic_16x16_2(1,1,(1+48),shi);
        display_graphic_16x16_2(1,1,(1+64),mo);
        display_graphic_16x16_2(1,1,(1+80),zu);
        display_graphic_16x16_2(1,1,(1+96),yan);
        display_graphic_16x16_2(1,1,(1+112),fa); //第一行

        display_graphic_16x16_2(1,3,1,sheng);
        display_graphic_16x16_2(1,3,(1+16),chan);
        display_graphic_16x16_2(1,3,(1+32),xiao);
        display_graphic_16x16_2(1,3,(1+48),shou);
        display_graphic_16x16_2(1,3,(1+64),fu);
        display_graphic_16x16_2(1,3,(1+80),wu);
        display_graphic_16x16_2(1,3,(1+96),yi);
        display_graphic_16x16_2(1,3,(1+112),ti); //第二行

        display_graphic_16x16_2(1,5,1,xian2);
        display_graphic_16x16_2(1,5,(1+16),jin);
        display_graphic_16x16_2(1,5,(1+32),wan);
        display_graphic_16x16_2(1,5,(1+48),bei);
        display_graphic_16x16_2(1,5,(1+64),shi2);
        display_graphic_16x16_2(1,5,(1+80),yan2);
        display_graphic_16x16_2(1,5,(1+96),che);
        display_graphic_16x16_2(1,5,(1+112),shi3);//第三行

        display_graphic_16x16_2(1,7,1,wan);
        display_graphic_16x16_2(1,7,(1+16),shan);
        display_graphic_16x16_2(1,7,(1+32),xi);
        display_graphic_16x16_2(1,7,(1+48),tong);
        display_graphic_16x16_2(1,7,(1+64),guan);
        display_graphic_16x16_2(1,7,(1+80),li);
        display_graphic_16x16_2(1,7,(1+96),ti2);
        display_graphic_16x16_2(1,7,(1+112),zhi);//第四行
        rt_thread_mdelay(1000);//M_Delay(600);

        clear_screen();
        display_graphic_16x16_2(1,1,1,test1); /*在第1页，第1列显示单个汉字"液"*/
        display_graphic_16x16_2(1,1,(1+16),test2);
        display_graphic_8x16_1(1,1,(1+32),test3); /*在第1页，第17列显示单个数字"1"*/
        display_graphic_8x16_1(1,1,(1+40),test4);

        display_graphic_11x16_1(1,3,1,test5);
        display_graphic_11x16_1(1,3,(1+11),test6);
        display_graphic_11x11_1(1,3,(1+22),test7);
        display_graphic_11x11_1(1,3,(1+33),test8);
        
        //while(1);

        rt_thread_mdelay(1000);//M_Delay(600);
    }
#endif



#if 0
uint8_t Temp_Data[20]={0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08};
int ReadNum=0;

rt_kprintf("write flash\n");
// Temp_Data[0]=0x01;
// Temp_Data[1]=0x02;
// Temp_Data[2]=0x03;
// Temp_Data[3]=0x04;
write_to_flash(0x03fa, Temp_Data, 8);

rt_kprintf("read flash\n");
memset(Temp_Data, 0, sizeof(Temp_Data));
//ReadNum=ReadFlashNByte(0x3fa0, Temp_Data, 4);//读取数据
//ReadNum = read_from_flash(0x3800, Temp_Data, 4);//读取数据
uint32_t sn = *(__IO uint32_t*)( 0x08003fb0 );
rt_kprintf("%08x\n", sn);

ReadNum = read_from_flash(0x3fb0, Temp_Data, 8);//读取数据
rt_kprintf("%02x %02x %02x %02x %02x %02x %02x %02x\n", Temp_Data[0],Temp_Data[1],Temp_Data[2],Temp_Data[3],Temp_Data[4],Temp_Data[5],Temp_Data[6],Temp_Data[7]);

write_to_flash2(0x03fa, sn);

// ReadNum = read_from_flash(0x3fb0, Temp_Data, 4);//读取数据
// rt_kprintf("%02x %02x %02x %02x\n", Temp_Data[0], Temp_Data[1],Temp_Data[2],Temp_Data[3]);

while(1);
#endif

    check_fds_broken(); /*检查文件系统是否损坏，若损坏，重新格式化文件*/
    time_synced = 0;
    //pthread_t thread;
    //pthread_create(&thread, NULL, test, NULL);
    uint32_t i = 0;
    time_t now;
    _use_console = 0;
#if defined(RT_USING_ADC)
    MX_ADCx_Init();   
#endif    
    alarm_init(32);
    whitelist_init();
    set_config("pn", DEVICE_PART_NUMBER);
#ifdef LANGUACE_EN
    set_config("language","en");
#endif
    set_default_mac();
    // set_config("vendor", "hengtai");
    // check_device_sn();
#ifdef GPKG_USING_WIZNET     
    wiz_init();   
#endif
    //初始化充电控制板和充电主程序
    ccm_init(NULL);
    charge_init();   
#ifdef SONGLI_DEFAULT
    set_songli_default_value();
#endif
    //初始化UI相关
#if defined(USING_CCM_C1X) || defined(USING_CCM_C5X) || defined(USING_CCM_C7X) || defined(USING_CCM_SIMULATOR)
    #ifndef USING_CCM_SIMULATOR
    init_gcard_device("/dev/uart1", 115200);
    #endif
#if defined(USING_C1_V100)
    rt_thread_mdelay(3000);
    if(_use_console==0) {
        rt_console_set_device("uart2");
        libc_stdio_set_console("uart2", O_RDWR);
        rt_thread_mdelay(100);
        ui_com_init("/dev/uart3", 115200);
        rt_thread_mdelay(100);
    }
#else
    ui_com_init("/dev/uart3", 115200);
    rt_thread_mdelay(3000);
#endif  
#endif
#if defined(USING_CCM_E1X)
    extern void init_ui_e1(const char *path, int baundrate);
    init_ui_e1("/dev/uart5", 115200);
    // set_charger_param(chg_cfg_max_allowed_minutes, 12*60);
#endif
#if !defined(USING_CCM_C4X)  
    //初始化后台进程
    backend_init(DEFAULT_BACKEND_ID);
    rt_thread_mdelay(2000);
    backend_start();
#endif

    beep(10);
    app(0,NULL);
#ifdef ENABLE_WATCH_DOG    
    if(is_iwdrst())
    {
        rt_kprintf("iwd reset occured!\n ");
        alarm_recovered(CONNECTOR_NONE, SYS_WDGRST, time(NULL), NULL);
    }
    // /*启动独立watch dog*/
    // iwdg_start(1000);
#endif
    /*處理斷電的訂單*/
    query_history_record(RECORD_CHARGING, NULL, query_charging_record_cb);
    while (1)
    {
        now = time(NULL);
#if defined(USING_CCM_E1X)
        check_pvd_status();
        charge_poll(now);
        alarm_poll(now);
        check_pvd_status();
        extern void ui_e1_poll(time_t now);
        ui_e1_poll(now); /*e1 按键刷卡处理*/
#else
        if (i % 3 == 0)
        {
            meter_process();
            // rt_thread_mdelay(100);
        }
        else if (i % 3 == 1)
        {
            check_pvd_status();
            charge_poll(now);
            alarm_poll(now);
            check_pvd_status();            
            rt_thread_mdelay(100);
        }
#if !defined(USING_CCM_C4X)
        else
        {
            rt_kprintf("------------------------- ui_com_poll(now)\n");
            //ui_com_poll(now);
            //struct tm *t = g_localtime(&now);
            GetRtcTime(now, rtcTime);
            if(i % 2 == 1)
                UiDisplay_Time(rtcTime[4], rtcTime[5], rtcTime[6]);
            else
                UiProgressLoop(); //duanma
            extern void *bk_loop_thread(void *param);
            bk_loop_thread(NULL);
        }
#endif
#endif      
#ifdef ENABLE_WATCH_DOG
        /*喂狗*/
        rt_device_control(wdg_dev, RT_DEVICE_CTRL_WDT_KEEPALIVE, NULL);
#endif        
        i++;
    }
}
#endif
static void printf_record(transaction *r)
{
    char user[32];
    char tid[17];
    tid[16] = 0;
    strncpy(tid, r->transaction_id, sizeof(tid));
    strncpy(user, r->user, sizeof(user));
    rt_kprintf("rid:%d,tid:%s,user:%s,bal:%d,cid:%d,mode:%d,para:%d,bm:%d,bt:%d,em:%d,et:%d,time:%d,cost:%d,reason:%d,state:%d,flag:%d\n",
               r->record_id,
               tid,
               user,
               r->balance,
               r->connector,
               r->charge_mode,
               r->charge_param,
               r->start_meter,
               r->start_time,
               r->stop_meter,
               r->stop_time,
               r->total_time,
               r->total_fee,
               r->stop_reason,
               r->state,
               r->sync_flag);
}

__attribute__((weak)) void simulate_card_swipe(char *cardid, char *customer, int bal, unsigned type)
{
    return;
}

static int _pages;
static int chg(int argc, char *argv[])
{
#define CMD_START_INDEX 0
#define CMD_STOP_INDEX 1
#define CMD_LIST_INDEX 2
#define CMD_RECORD_INDEX 3
#define CMD_NEXT_INDEX 4
    int i;
    //static transaction record;
    static query_stm_t q = 0;
    const char *help_info[] =
        {
            [CMD_START_INDEX] = "chg start <connector> [user] [pay] - start charge at given connector by given userid and payment",
            [CMD_STOP_INDEX] = "chg stop <connector>               - stop charge by given connector'",
            [CMD_LIST_INDEX] = "chg list [connector]               - list all charging transactions",
            [CMD_RECORD_INDEX] = "chg query [type] [user]            - query record by type",
            [CMD_NEXT_INDEX] = "chg step [number]                  - display record by step",
        };
    if (argc < 2)
    {
        rt_kprintf("Usage:\n");
        for (i = 0; i < sizeof(help_info) / sizeof(char *); i++)
        {
            rt_kprintf("%s\n", help_info[i]);
        }
        rt_kprintf("\n");
    }
    else
    {
        const char *operator= argv[1];
        int cid;
        char user[32];
        memset(user, 0, sizeof(user));
        if (!strcmp("start", operator))
        {
            if (argc == 5)
            {
                strncpy(user, argv[3], sizeof(user));
                cid = atoi(argv[2]);
                start_charge(user, atoi(argv[4]), cid, AUTH_MODE_ADMIN, CHARGE_MODE_AUTO, 0, 0);
            }
            else if (argc == 6)
            {
                strncpy(user, argv[3], sizeof(user));
                cid = atoi(argv[2]);
                start_charge(user, atoi(argv[4]), cid, atoi(argv[5]), CHARGE_MODE_AUTO, 0, 0);
            }
            else
            {
                rt_kprintf("%s\n", help_info[CMD_START_INDEX]);
            }
        }
        else if (!strcmp("stop", operator))
        {
            if (argc < 3)
            {
                rt_kprintf("%s\n", help_info[CMD_STOP_INDEX]);
            }
            cid = atoi(argv[2]);
            stop_charge(cid, 0);
        }
        else if (!strcmp("list", operator))
        {
            for (i = 0; i < get_connector_count(); i++)
            {
                if (get_transaction(i))
                {
                    printf_record(get_transaction(i));
                }
            }
        }
        else if (!strcmp("query", operator))
        {
            if (argc == 4)
            {
                if (!q)
                {
                    rt_kprintf("prepare to query type %d, user=%s\n", atoi(argv[2]), argv[3]);
                    q = get_history_record_prepare(atoi(argv[2]), argv[3]);
                }
            }
            else if (argc == 3)
            {
                if (!q)
                {
                    rt_kprintf("prepare to query type %d\n", atoi(argv[2]));
                    q = get_history_record_prepare(atoi(argv[2]), NULL);
                }
            }
            else
            {
                rt_kprintf("%s\n", help_info[CMD_RECORD_INDEX]);
            }
        }
        else if (!strcmp("step", operator))
        {
            int number = 10;
            transaction *r = malloc(sizeof(transaction));
            if(!r) {
                rt_kprintf("malloc memory for transaction failed!");
                return 0;
            }
            if (argc == 3)
                number = atoi(argv[2]);
            for (i = 0; i < number; i++)
            {
                if (!q)
                {
                    rt_kprintf("please exec query prepare first\n");
                    break;
                }
                if (get_history_record_step(q, r))
                {
                    printf_record(r);
                }
                else
                {
                    get_history_record_finalize(q);
                    q = NULL;
                    rt_kprintf("finish query\n");
                    break;
                }
            }
            free(r);
        }
        else if (!strcmp("bench", operator))
        {
            int count = 100;
            transaction *r = malloc(sizeof(transaction));
            if(!r) {
                rt_kprintf("malloc memory for transaction failed!");
                return 0;
            }            
            if (argc > 3)
            {
                count = atoi(argv[2]);
                for (i = 0; i < count; i++)
                {
                    memset(r, 0, sizeof(transaction));
                    r->record_id = generate_record_id();
                    r->start_time = time(NULL);
                    r->state = CS_CHARGE_FINISH;
                    strncpy(r->user, argv[3], sizeof(r->user));
                    update_history_record(r);
                    rt_kprintf("add record %d\n", r->record_id);
                }
            }
            else
            {
                rt_kprintf("chg bench [count] [user]   - sync bench add record\n");
            }
            free(r);
        }
        else if (!strcmp("sync", operator))
        {
            if (argc == 4)
            {
                sync_history_record(atoi(argv[2]), atoi(argv[3]));
            }
            else
            {
                rt_kprintf("chg sync [id] [flag]   - sync record \n");
            }
        }
        else if (!strcmp("stat", operator))
        {
            for (i = 0; i < get_connector_count(); i++)
            {
                rt_kprintf("cid:%d,status:%d,p:%d,e:%d,c:%d,v:%d,t:%d\n", i,
                           ccm_get_gun_state(i)->status,
                           ccm_get_gun_state(i)->power,
                           ccm_get_gun_state(i)->elec,
                           ccm_get_gun_state(i)->current_a,
                           ccm_get_gun_state(i)->voltage_a,
                           ccm_get_gun_state(i)->temperature);
            }
        }
        else if (!strcmp("tariff", operator))
        {
            tariff *t = get_tariff();

            printf("tariff id:%d, count:%d, type:%d\n", t->id,t->count,t->type);
            if(t->type==TARIFF_BY_ELEC)
            {
                for(i=0;i<t->count;i++) {
                    printf("%d[tag:%d,time:%d,elec:%d,sevice:%d]\n",i,t->tariff[i].elec.tag ,t->tariff[i].elec.time_start, t->tariff[i].elec.elec_price,t->tariff[i].elec.service_price);
                }
            }
            else if(t->type==TARIFF_BY_TIME) 
            {
                for(i=0;i<t->count;i++) {
                    printf("%d[power:%d,price:%d,price_min:%d]\n",i,t->tariff[i].time.power_start, t->tariff[i].time.price,t->tariff[i].time.price_min);
                }
            }
        }
        else if (!strcmp("settariff", operator))
        {
            tariff *st = malloc(sizeof(tariff));
            tariff *t = get_tariff();
            if(!st) {
                rt_kprintf("malloc memory for tariff failed!");
                return 0;
            }
            if(argc==2) {
                memset(st, 0, sizeof(tariff));
                set_tariff(st);
            }
            else if(argc==6) {
                memcpy(st, t, sizeof(tariff));
                st->id = 1;
                st->type = TARIFF_BY_ELEC;
                st->count++;
                if(st->count <=0 || st->count > MAX_TARIFF_SECTION_NUMBER)
                {
                    rt_kprintf("unsupport tariff count\r\n");
                    return 0;
                }
                st->tariff[st->count-1].elec.time_start = atoi(argv[2]);
                st->tariff[st->count-1].elec.tag = atoi(argv[3]);
                st->tariff[st->count-1].elec.elec_price = atoi(argv[4]);
                st->tariff[st->count-1].elec.service_price = atoi(argv[5]);
                set_tariff(st);
            }
            else {
                printf("chg settariff time elec serice ...\n");
            }
            free(st);
        }      
        else if(!strcmp("smcard",operator))  
        {
            extern void simulate_card_swipe(char *cardid, char *customer, int bal, unsigned type);
            if(argc!=6) {
                return 0;
            }
            simulate_card_swipe(argv[2],argv[3],atoi(argv[4]),atoi(argv[5]));
        }
        else
        {
            rt_kprintf("Usage:\n");
            for (i = 0; i < sizeof(help_info) / sizeof(char *); i++)
            {
                rt_kprintf("%s\n", help_info[i]);
            }
            rt_kprintf("\n");
        }
    }
    return 0;
}

// void reset(uint8_t argc, char **argv)
// {
//     reboot();
// }

static int card(int argc, char *argv[])
{
    CardInfo info;
    CardInitialisation init;
    int ret;
    if(argc<2) {
        goto _show_help;
    }
    else {
        if(strcmp(argv[1],"read")==0) {
            memset(&info, 0, sizeof(info));
            ret = card_read(&info);
            if(ret==CR_INVALID) {
                printf("invalid card! serialid=%02X%02X%02X%02X\n", info.serialid[0],info.serialid[1],info.serialid[2],info.serialid[3]);
            }
            else if(ret==CR_SUCESS) {
                printf("serialid=%02X%02X%02X%02X, userid:%s, type:%d, balance:%d, status:%d\n", info.serialid[0],info.serialid[1],info.serialid[2],info.serialid[3],
                                    info.userid, info.type, info.balance, info.status);
            }
            else if(ret==CR_TIMEOUT){
                printf("read card timeout!\n");
            }
            else{
                printf("read card error %d!\n",ret);
            }            
        }
        else if(strcmp(argv[1],"create")==0) {
            if(argc<4) {
                goto _show_help;
            }
            memset(&init, 0, sizeof(init));
            if(atoi(argv[2])==0)
                init.type = WALLET_CARD;
            else if(atoi(argv[2])==1)
                init.type = ID_CARD;
            else
                init.type = MANAGE_CARD;
            strncpy(init.userid, argv[3], 17);
            if(argc==5) {
                init.haspassword = 1;
                strncpy(init.password, argv[4], 6);
            }
            ret = card_create(&init);
            if(ret==CR_SUCESS) {
                printf("create card [%s] success!\n", argv[3]);
            }
            else {
                printf("create card failed %d!\n", ret);
            }
        }
        else if(strcmp(argv[1],"lock")==0) {
            if(argc==3) {
                ret = card_lock(argv[2]);
            }
            else
                ret = card_lock(env_get("sn"));
        }
        else if(strcmp(argv[1],"clear")==0) {
            card_clear();
        }
        else if(strcmp(argv[1],"unlock")==0) {
            card_unlock();
        }
        else if(strcmp(argv[1],"deduct")==0) {
            if(argc!=3) goto _show_help;
            ret = card_deduct(atoi(argv[2]));
            if(ret==CR_SUCESS) {
                printf("card deduct [%s] success!\n", argv[2]);
            }
            else {
                printf("card deduct failed %d!\n", ret);
            }            
        }
        else if(strcmp(argv[1],"recharge")==0) {
            if(argc!=3) goto _show_help;
            ret = card_recharge(atoi(argv[2]));
            if(ret==CR_SUCESS) {
                printf("card recharge [%s] success!\n", argv[2]);
            }
            else {
                printf("card recharge failed %d!\n", ret);
            }                
        }     
        else if(strcmp(argv[1],"test")==0) {
            if(card_test())
            {
                printf("card reader test failed!\n");
            }
            else {
                printf("card reader test success!\n");
            }
        }     
        else
            goto _show_help;                     
    }
	return 0;
_show_help:
    printf("card read           - read m1 card\n");
    printf("card create type id [pw] - create card type=[0-paycard,1-idcard,3-manage] id=[id] password=pw\n");
    printf("card lock [sn]      - lock card with station sn\n");
    printf("card unlock         - unlock card\n");
    printf("card deduct value   - deduct card balance with given value\n");
    printf("card recharge value - recharge card balance with given value\n");
    return 0;
}

static void alm(int argc, char *argv[])
{
    galarm am;
    static query_stm_t q=0;
    int i;
    if(argc < 2)
        goto _show_help;
    if(strcmp(argv[1],"list")==0) {
        if(argc < 3)
            print_alarm_list(2);
        else
            print_alarm_list(atoi(argv[2]));
    }
    else if(strcmp(argv[1],"query")==0) {
       if (argc == 4)
       {
           if (!q)
           {
               rt_kprintf("prepare to alarm query type %d, time=%s\n", atoi(argv[2]), argv[3]);
               q = get_history_alarm_prepare(atoi(argv[2]), argv[3]);
           }
       }
       else if (argc == 3)
       {
           if (!q)
           {
               rt_kprintf("prepare to alarm query type %d\n", atoi(argv[2]));
               q = get_history_alarm_prepare(atoi(argv[2]), NULL);
           }
       }
       else
       {
           goto _show_help;
       }         
    }
    else if(strcmp(argv[1],"step")==0) {
       int number = 10;
       if (argc == 3)
           number = atoi(argv[2]);
       for (i = 0; i < number; i++)
       {
           if (!q)
           {
               rt_kprintf("please exec alarm query prepare first\n");
               break;
           }
           if (get_history_alarm_step(q, &am))
           {
               print_alarm(&am);
           }
           else
           {
               get_history_alarm_finalize(q);
               q = NULL;
               rt_kprintf("finish alarm query\n");
               break;
           }
       }
    }
    else if(strcmp(argv[1],"start")==0) {
        if(argc!=4)
           goto _show_help;
        alarm_occured(atoi(argv[2]), atoi(argv[3]),time(NULL),NULL);
    }
    else if(strcmp(argv[1],"stop")==0) {
        if(argc!=4)
           goto _show_help;
        alarm_recovered(atoi(argv[2]), atoi(argv[3]),time(NULL),NULL);
    }
    return;
_show_help:
    printf("alm list                 - list current alarms\n");
    printf("alm query type [time]    - query alarm history prepare, type[0-all 1-unsync 2-by time], time[ex:20190419113000]\n");
    printf("alm step number          - list query result of alarm history record\n");
    printf("alm start connector code - simulate to occur an alarm\n");
    printf("alm stop connector code  - simulate to recover an alarm\n");
}

static int app(int argc, char *argv[])
{
    rt_kprintf("APP VERSION: %d\n",APP_VERSION);
    rt_kprintf("BUILD DATE: %s\n",__DATE__);
    rt_kprintf("PN : %s\n",DEVICE_PART_NUMBER);
    rt_kprintf("SERIALID: %s\n", get_factory_id());
    return 0;
}

static int ling(int argc, char *argv[])
{
    _use_console = 1;
    return 0;
}
// #define FINSH_DEBUG_CMD
#ifdef FINSH_USING_MSH
#include <finsh.h>
MSH_CMD_EXPORT(app, app operator);
// MSH_CMD_EXPORT(ling, enter console);

MSH_CMD_EXPORT(chg, chg operator);
// MSH_CMD_EXPORT(ling, enter console);
MSH_CMD_EXPORT(reboot, reboot system);
MSH_CMD_EXPORT(reset, factory reset);
#ifdef FINSH_DEBUG_CMD
// MSH_CMD_EXPORT(card, m1 card operator);
#endif
MSH_CMD_EXPORT(alm, alarm operator);
#endif
#endif

#if 0
int main(void)
{
    while(1)
    {
        rt_thread_mdelay(100);
    }
}
#endif